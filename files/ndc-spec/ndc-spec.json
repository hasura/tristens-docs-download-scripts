{
    "files/ndc-spec/overview.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Overview\n\nHasura data connectors allow you to extend the functionality of the Hasura server by providing web services which can resolve new sources of data. By following this specification, those sources of data can be added to your Hasura graph, and the usual Hasura features such as relationships and permissions will be supported for your data source.\n\nThis specification is designed to be as general as possible, supporting many different types of data source, while still being targeted enough to provide useful features with high performance guarantees. It is important to note that data connectors are designed for tabular data which supports efficient filtering and sorting. If you are able to model your data source given these constraints, then it will be a good fit for a data connector, but if not, you might like to consider a GraphQL remote source integration with Hasura instead.",
    "files/ndc-spec/.md": "# Hasura Data Connectors Developer's Guide\n\n# Overview\n\nHasura data connectors allow you to extend the functionality of the Hasura server by providing web services which can resolve new sources of data. By following this specification, those sources of data can be added to your Hasura graph, and the usual Hasura features such as relationships and permissions will be supported for your data source.\n\nThis specification is designed to be as general as possible, supporting many different types of data source, while still being targeted enough to provide useful features with high performance guarantees. It is important to note that data connectors are designed for tabular data which supports efficient filtering and sorting. If you are able to model your data source given these constraints, then it will be a good fit for a data connector, but if not, you might like to consider a GraphQL remote source integration with Hasura instead.",
    "files/ndc-spec/tutorial/explain.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Explain\n\nThe `/explain` endpoint is not implemented in the reference implementation, simply because tje `QueryResponse` is interpreted directly in the `/query` endpoint. There is no intermediate representation (such as SQL) which could be described as a \"query plan\".\n\nThe `explain` capability is turned off in the[ capabilities endpoint ](./capabilities.html), and the `/explain` endpoint throws an error:\n\n```\nasync\nfn   post_explain\n(\n    Json(_request): Json<models::QueryRequest>,\n) ->\nResult\n<Json<models::ExplainResponse>> {\nErr\n((\n        StatusCode::NOT_IMPLEMENTED,\n        Json(models::ErrorResponse {\n            message:\n\"explain is not supported\"\n.into(),\n            details: serde_json::Value::Null,\n        }),\n    ))\n}\n```",
    "files/ndc-spec/tutorial/index.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Tutorial\n\nIn this tutorial, we will walk through the *reference implementation* of the specification, which will illustrate how to implement data connectors from scratch.\n\nThe reference implementation is written in Rust, but it should be possible to follow along using any language of your choice, as long as you can implement a basic web server and implement serializers and deserializers for the data formats involved.\n\nIt is recommended that you follow along chapter-by-chapter, as each will build on the last.",
    "files/ndc-spec/tutorial/capabilities.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Capabilities\n\nThe[ capabilities endpoint ](../specification/capabilities.html)should return data describing which features the data connector can implement, along with a range of versions of this specification that the data connector claims to implement.\n\nThe reference implementation returns a static `CapabilitiesResponse` :\n\n```\nasync\nfn   get_capabilities\n() -> Json<models::CapabilitiesResponse> {\n    Json(models::CapabilitiesResponse {\n        versions:\n\"^0.1.0\"\n.into(),\n        capabilities: models::Capabilities {\n            explain:\nNone\n,\n            query: models::QueryCapabilities {\n                aggregates:\nSome\n(LeafCapability {}),\n                variables:\nSome\n(LeafCapability {}),\n            },\n            relationships:\nSome\n(RelationshipCapabilities {\n                order_by_aggregate:\nSome\n(LeafCapability {}),\n                relation_comparisons:\nSome\n(LeafCapability {}),\n            }),\n        },\n    })\n}\n```\n\n *Note* : the reference implementation supports all capabilities with the exception of `explain` . This is because all queries are run in memory by naively interpreting the query request - there is no better description of the query plan than the raw query request itself!",
    "files/ndc-spec/tutorial/schema.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Schema\n\nThe schema endpoint should return data describing the data connector's scalar and object types, along with any collections, functions and procedures which are exposed.\n\n```\nasync\nfn   get_schema\n() -> Json<models::SchemaResponse> {\n// ...\nJson(models::SchemaResponse {\n        scalar_types,\n        object_types,\n        collections,\n        functions,\n        procedures,\n    })\n}\n```\n\n## Scalar Types\n\nWe define two scalar types: `String` and `Int` .\n\n `String` supports a custom `like` comparison operator, and `Int` supports custom aggregation operators `min` and `max` .\n\n```\nlet\nscalar_types = BTreeMap::from_iter([\n        (\n\"String\"\n.into(),\n            models::ScalarType {\n                aggregate_functions: BTreeMap::new(),\n                comparison_operators: BTreeMap::from_iter([(\n\"like\"\n.into(),\n                    models::ComparisonOperatorDefinition {\n                        argument_type: models::Type::Named {\n                            name:\n\"String\"\n.into(),\n                        },\n                    },\n                )]),\n            },\n        ),\n        (\n\"Int\"\n.into(),\n            models::ScalarType {\n                aggregate_functions: BTreeMap::from_iter([\n                    (\n\"max\"\n.into(),\n                        models::AggregateFunctionDefinition {\n                            result_type: models::Type::Nullable {\n                                underlying_type:\nBox\n::new(models::Type::Named {\n                                    name:\n\"Int\"\n.into(),\n                                }),\n                            },\n                        },\n                    ),\n                    (\n\"min\"\n.into(),\n                        models::AggregateFunctionDefinition {\n                            result_type: models::Type::Nullable {\n                                underlying_type:\nBox\n::new(models::Type::Named {\n                                    name:\n\"Int\"\n.into(),\n                                }),\n                            },\n                        },\n                    ),\n                ]),\n                comparison_operators: BTreeMap::from_iter([]),\n            },\n        ),\n    ]);\n```\n\n## Object Types\n\nFor each collection, we define an object type for its rows:\n\n```\nlet\nobject_types = BTreeMap::from_iter([\n        (\n\"article\"\n.into(), article_type),\n        (\n\"author\"\n.into(), author_type),\n    ]);\n```\n\n### Author\n\n```\nlet\nauthor_type = models::ObjectType {\n        description:\nSome\n(\n\"An author\"\n.into()),\n        fields: BTreeMap::from_iter([\n            (\n\"id\"\n.into(),\n                models::ObjectField {\n                    description:\nSome\n(\n\"The author's primary key\"\n.into()),\n                    r#\ntype :  models\n::Type::Named { name:\n\"Int\"\n.into() },\n                },\n            ),\n            (\n\"first_name\"\n.into(),\n                models::ObjectField {\n                    description:\nSome\n(\n\"The author's first name\"\n.into()),\n                    r#\ntype :  models\n::Type::Named {\n                        name:\n\"String\"\n.into(),\n                    },\n                },\n            ),\n            (\n\"last_name\"\n.into(),\n                models::ObjectField {\n                    description:\nSome\n(\n\"The author's last name\"\n.into()),\n                    r#\ntype :  models\n::Type::Named {\n                        name:\n\"String\"\n.into(),\n                    },\n                },\n            ),\n        ]),\n    };\n```\n\n### Article\n\n```\nlet\narticle_type = models::ObjectType {\n        description:\nSome\n(\n\"An article\"\n.into()),\n        fields: BTreeMap::from_iter([\n            (\n\"id\"\n.into(),\n                models::ObjectField {\n                    description:\nSome\n(\n\"The article's primary key\"\n.into()),\n                    r#\ntype :  models\n::Type::Named { name:\n\"Int\"\n.into() },\n                },\n            ),\n            (\n\"title\"\n.into(),\n                models::ObjectField {\n                    description:\nSome\n(\n\"The article's title\"\n.into()),\n                    r#\ntype :  models\n::Type::Named {\n                        name:\n\"String\"\n.into(),\n                    },\n                },\n            ),\n            (\n\"author_id\"\n.into(),\n                models::ObjectField {\n                    description:\nSome\n(\n\"The article's author ID\"\n.into()),\n                    r#\ntype :  models\n::Type::Named { name:\n\"Int\"\n.into() },\n                },\n            ),\n        ]),\n    };\n```\n\n## Collections\n\nWe define each collection's schema using the type information defined above:\n\n```\nlet\ncollections =\nvec!\n[\n        articles_collection,\n        authors_collection,\n        articles_by_author_collection,\n    ];\n```\n\n### Author\n\n```\nlet\nauthors_collection = models::CollectionInfo {\n        name:\n\"authors\"\n.into(),\n        description:\nSome\n(\n\"A collection of authors\"\n.into()),\n        collection_type:\n\"author\"\n.into(),\n        arguments: BTreeMap::new(),\n        foreign_keys: BTreeMap::new(),\n        uniqueness_constraints: BTreeMap::from_iter([(\n\"AuthorByID\"\n.into(),\n            models::UniquenessConstraint {\n                unique_columns:\nvec!\n[\n\"id\"\n.into()],\n            },\n        )]),\n    };\n```\n\n### Article\n\n```\nlet\narticles_collection = models::CollectionInfo {\n        name:\n\"articles\"\n.into(),\n        description:\nSome\n(\n\"A collection of articles\"\n.into()),\n        collection_type:\n\"article\"\n.into(),\n        arguments: BTreeMap::new(),\n        foreign_keys: BTreeMap::from_iter([(\n\"Article_AuthorID\"\n.into(),\n            models::ForeignKeyConstraint {\n                foreign_collection:\n\"authors\"\n.into(),\n                column_mapping: BTreeMap::from_iter([(\n\"author_id\"\n.into(),\n\"id\"\n.into())]),\n            },\n        )]),\n        uniqueness_constraints: BTreeMap::from_iter([(\n\"ArticleByID\"\n.into(),\n            models::UniquenessConstraint {\n                unique_columns:\nvec!\n[\n\"id\"\n.into()],\n            },\n        )]),\n    };\n```\n\n### articles_by_author\n\nWe define one additional collection, `articles_by_author` , which is provided as an example of a collection with an argument:\n\n```\nlet\narticles_by_author_collection = models::CollectionInfo {\n        name:\n\"articles_by_author\"\n.into(),\n        description:\nSome\n(\n\"Articles parameterized by author\"\n.into()),\n        collection_type:\n\"article\"\n.into(),\n        arguments: BTreeMap::from_iter([(\n\"author_id\"\n.into(),\n            models::ArgumentInfo {\n                argument_type: models::Type::Named { name:\n\"Int\"\n.into() },\n                description:\nNone\n,\n            },\n        )]),\n        foreign_keys: BTreeMap::new(),\n        uniqueness_constraints: BTreeMap::new(),\n    };\n```\n\n## Functions\n\nThe schema defines a list of[ functions ](../specification/schema/functions.html), each including its input and output[ types ](../specification/types.html).\n\n### Get Latest Article\n\nAs an example, we define a `latest_article_id` function, which returns a single integer representing the maximum article ID.\n\n```\nlet\nlatest_article_id_function = models::FunctionInfo {\n        name:\n\"latest_article_id\"\n.into(),\n        description:\nSome\n(\n\"Get the ID of the most recent article\"\n.into()),\n        result_type: models::Type::Nullable {\n            underlying_type:\nBox\n::new(models::Type::Named { name:\n\"Int\"\n.into() }),\n        },\n        arguments: BTreeMap::new(),\n    };\n```\n\n## Procedures\n\nThe schema defines a list of[ procedures ](../specification/schema/procedures.html), each including its input and output[ types ](../specification/types.html).\n\n### Upsert Article\n\nAs an example, we define an *upsert* procedure for the article collection defined above. The procedure will accept an input argument of type `article` , and returns a nulcollection `article` , representing the state of the article before the update, if it were already present.\n\n```\nlet\nupsert_article = models::ProcedureInfo {\n        name:\n\"upsert_article\"\n.into(),\n        description:\nSome\n(\n\"Insert or update an article\"\n.into()),\n        arguments: BTreeMap::from_iter([(\n\"article\"\n.into(),\n            models::ArgumentInfo {\n                description:\nSome\n(\n\"The article to insert or update\"\n.into()),\n                argument_type: models::Type::Named {\n                    name:\n\"article\"\n.into(),\n                },\n            },\n        )]),\n        result_type: models::Type::Nullable {\n            underlying_type:\nBox\n::new(models::Type::Named {\n                name:\n\"article\"\n.into(),\n            }),\n        },\n    };\n```",
    "files/ndc-spec/tutorial/health.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Health and Metrics\n\n## Service Health\n\nThe `/healthz` endpoint has nothing to check, because the reference implementation does not need to connect to any other services. Therefore, once the reference implementation is running, it can always report a healthy status:\n\n```\nasync\nfn   get_healthz\n() -> StatusCode {\n    StatusCode::NO_CONTENT\n}\n```\n\nIn practice, a connector should make sure that any upstream services can be successfully contacted, and respond accordingly.\n\n## Metrics\n\nThe reference implementation maintains some generic access metrics in its application state:\n\n- `metrics.total_requests` counts the number of requests ever served, and\n- `metrics.active_requests` counts the number of requests *currently* being served.\n\n\nThe[ metrics endpoint ](../specification/metrics.html)reports these metrics using the Rust[ prometheus ](https://docs.rs/prometheus/latest/prometheus/)crate:\n\n```\nasync\nfn   get_metrics\n(State(state): State<Arc<Mutex<AppState>>>) ->\nResult\n<\nString\n> {\nlet\nstate = state.lock().\nawait\n;\n    state.metrics.as_text().ok_or((\n        StatusCode::INTERNAL_SERVER_ERROR,\n        Json(models::ErrorResponse {\n            message:\n\"cannot encode metrics\"\n.into(),\n            details: serde_json::Value::Null,\n        }),\n    ))\n}\n```\n\nTo maintain these metrics, it uses a simple metrics middleware:\n\n```\nasync\nfn   metrics_middleware\n<T>(\n    state: State<Arc<Mutex<AppState>>>,\n    request: axum::http::Request<T>,\n    next: axum::middleware::Next<T>,\n) -> axum::response::Response {\n// Don't hold the lock to update metrics, since the\n// lock doesn't protect the metrics anyway.\nlet\nmetrics = {\nlet\nstate = state.lock().\nawait\n;\n        state.metrics.clone()\n    };\n\n    metrics.total_requests.inc();\n    metrics.active_requests.inc();\nlet\nresponse = next.run(request).\nawait\n;\n    metrics.active_requests.dec();\n    response\n}\n```",
    "files/ndc-spec/tutorial/setup.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Setup\n\nTo compile and run the reference implementation, you will need to install a Rust toolchain, and then run:\n\n```\ngit\nclone\ngit@github.com:hasura/ndc-spec.git\ncd\nndc-spec/ndc-reference\ncargo build\ncargo run\n```\n\nAlternatively, you can run the reference implementation entirely inside a Docker container:\n\n```\ngit\nclone\ngit@github.com:hasura/ndc-spec.git\ncd\nndc-spec\ndocker build -t reference_connector .\ndocker run -it reference_connector\n```\n\nEither way, you should have a working data connector running on[ http://localhost:8100/ ](http://localhost:8100/), which you can test as follows:\n\n`curl http://localhost:8100/schema`",
    "files/ndc-spec/tutorial/testing.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Testing\n\nTesting tools are provided in the specification repository to aid in the development of connectors.\n\n## ndc-test\n\nThe `ndc-test` executable performs basic validation of the data returned by the capabilities and schema endpoints, and performs some basic queries.\n\nTo test a connector, provide its endpoint to `ndc-test` on the command line:\n\n`ndc-test --endpoint <ENDPOINT>`\n\nFor example, running the reference connector and passing its URL to `ndc-test` , we will see that it issues test queries against the `articles` and `authors` collections:\n\n`ndc-test test --endpoint http://localhost:8100\n\nCapabilities\n├ Fetching /capabilities ... ... OK\n├ Validating capabilities ... OK\nSchema\n├ Fetching /schema ... OK\n├ Validating schema ...\n│ ├ object_types ... OK\n│ ├ Collections ...\n│ │ ├ articles ...\n│ │ │ ├ Arguments ... OK\n│ │ │ ├ Collection type ... OK\n│ │ ├ authors ...\n│ │ │ ├ Arguments ... OK\n│ │ │ ├ Collection type ... OK\n│ │ ├ articles_by_author ...\n│ │ │ ├ Arguments ... OK\n│ │ │ ├ Collection type ... OK\n│ ├ Functions ...\n│ │ ├ latest_article_id ...\n│ │ │ ├ Result type ... OK\n│ │ │ ├ Arguments ... OK\n│ │ ├ Procedures ...\n│ │ │ ├ upsert_article ...\n│ │ │ │ ├ Result type ... OK\n│ │ │ │ ├ Arguments ... OK\nQuery\n├ articles ...\n│ ├ Simple queries ...\n│ │ ├ Select top N ... OK\n│ │ ├ Predicates ... OK\n│ ├ Aggregate queries ...\n│ │ ├ star_count ... OK\n├ authors ...\n│ ├ Simple queries ...\n│ │ ├ Select top N ... OK\n│ │ ├ Predicates ... OK\n│ ├ Aggregate queries ...\n│ │ ├ star_count ... OK\n├ articles_by_author ...`\n\nHowever, `ndc-test` cannot validate the entire schema. For example, it will not issue queries against the `articles_by_author` collection, because it does not have any way to synthesize inputs for its required collection argument.",
    "files/ndc-spec/tutorial/getting-started.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Getting Started\n\nThe reference implementation will serve queries and mutations based on in-memory data read from CSV files.\n\nFirst, we will define some types to represent the data in the CSV files. Rows of CSV data will be stored in memory as ordered maps:\n\n```\ntype   Row\n= BTreeMap<\nString\n, serde_json::Value>;\n```\n\nOur application state will consist of collections of various types of rows:\n\n```\n#[derive(Debug, Clone)]\npub\nstruct   AppState\n{\npub\narticles: BTreeMap<\ni64\n, Row>,\npub\nauthors: BTreeMap<\ni64\n, Row>,\npub\nmetrics: Metrics,\n}\n```\n\nIn our `main` function, the data connector reads the initial data from the CSV files, and creates the `AppState` :\n\n```\nfn   init_app_state\n() -> AppState {\n// Read the CSV data files\nlet\narticles = read_csv(\n\"articles.csv\"\n).unwrap();\nlet\nauthors = read_csv(\n\"authors.csv\"\n).unwrap();\nlet\nmetrics = Metrics::new().unwrap();\n\n    AppState {\n        articles,\n        authors,\n        metrics,\n    }\n}\n```\n\nFinally, we start a web server with the endpoints which are required by this specification:\n\n```\n#[tokio::main]\nasync\nfn   main\n() {\nlet\napp_state = Arc::new(Mutex::new(init_app_state()));\nlet\napp = Router::new()\n        .route(\n\"/healthz\"\n, get(get_healthz))\n        .route(\n\"/metrics\"\n, get(get_metrics))\n        .route(\n\"/capabilities\"\n, get(get_capabilities))\n        .route(\n\"/schema\"\n, get(get_schema))\n        .route(\n\"/query\"\n, post(post_query))\n        .route(\n\"/mutation\"\n, post(post_mutation))\n        .route(\n\"/explain\"\n, post(post_explain))\n        .layer(axum::middleware::from_fn_with_state(\n            app_state.clone(),\n            metrics_middleware,\n        ))\n        .with_state(app_state);\n// run it with hyper on localhost:8100\naxum::Server::bind(&\n\"0.0.0.0:8100\"\n.parse().unwrap())\n        .serve(app.into_make_service())\n        .\nawait\n.unwrap();\n}\n```\n\n *Note* : the application state is stored in an `Arc<Mutex<_>>` , so that we can perform locking reads and writes in multiple threads.\n\nIn the next chapters, we will look at the implementation of each of these endpoints in turn.",
    "files/ndc-spec/tutorial/mutations/procedures.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Procedures\n\nThe `execute_procedure` function is responsible for executing a single procedure:\n\n```\nfn   execute_procedure\n(\n    state: &\nmut\nAppState,\n    name: &\nstr\n,\n    arguments: &BTreeMap<\nString\n, serde_json::Value>,\n    fields: &\nOption\n<IndexMap<\nString\n, models::Field>>,\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n) -> std::result::\nResult\n<models::MutationOperationResults, (StatusCode, Json<models::ErrorResponse>)>\n```\n\nThe function receives the application `state` , along with the `name` of the procedure to invoke, a list of `arguments` , a list of `fields` to return, and a list of `collection_relationships` .\n\nThe function matches on the name of the procedure, and fails if the name is not recognized. Currently there is only a single implemented procedure, `upsert_article` , and the function delegates to the `execute_upsert_article` function to handle it.\n\n```\n{\nmatch\nname {\n\"upsert_article\"\n=> {\n            execute_upsert_article(state, arguments, fields, collection_relationships)\n        }\n        _ =>\nErr\n((\n            StatusCode::BAD_REQUEST,\n            Json(models::ErrorResponse {\n                message:\n\"unknown procedure\"\n.into(),\n                details: serde_json::Value::Null,\n            }),\n        )),\n    }\n}\n```\n\n## upsert_article\n\nThe `execute_upsert_article` function reads the `article` argument from the `arguments` list, failing if it is not found or invalid.\n\nIt then inserts or updates that article in the application state, depending on whether or not an article with that `id` already exists or not.\n\nFinally, it delegates to the `eval_field` function to evaluate each requested field in turn, and returns a single row and column (named `__value` ) containing the result.\n\n `affected_rows` contains `1` to indicate that one row of data was affected.\n\n```\nfn   execute_upsert_article\n(\n    state: &\nmut\nAppState,\n    arguments: &BTreeMap<\nString\n, serde_json::Value>,\n    fields: &\nOption\n<IndexMap<\nString\n, models::Field>>,\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n) -> std::result::\nResult\n<models::MutationOperationResults, (StatusCode, Json<models::ErrorResponse>)>\n{\nlet\narticle = arguments.get(\n\"article\"\n).ok_or((\n        StatusCode::BAD_REQUEST,\n        Json(models::ErrorResponse {\n            message:\n\" \"\n.into(),\n            details: serde_json::Value::Null,\n        }),\n    ))?;\nlet\narticle_obj = article.as_object().ok_or((\n        StatusCode::BAD_REQUEST,\n        Json(models::ErrorResponse {\n            message:\n\" \"\n.into(),\n            details: serde_json::Value::Null,\n        }),\n    ))?;\nlet\nid = article_obj.get(\n\"id\"\n).ok_or((\n        StatusCode::BAD_REQUEST,\n        Json(models::ErrorResponse {\n            message:\n\" \"\n.into(),\n            details: serde_json::Value::Null,\n        }),\n    ))?;\nlet\nid_int = id.as_i64().ok_or((\n        StatusCode::BAD_REQUEST,\n        Json(models::ErrorResponse {\n            message:\n\" \"\n.into(),\n            details: serde_json::Value::Null,\n        }),\n    ))?;\nlet\nnew_row = BTreeMap::from_iter(article_obj.iter().map(|(k, v)| (k.clone(), v.clone())));\nlet\nold_row = state.articles.insert(id_int, new_row);\nlet\nreturning = old_row\n        .map(|old_row| {\nlet\nmut\nrow = IndexMap::new();\nfor\nfields\nin\nfields.iter() {\nfor\n(field_name, field)\nin\nfields.iter() {\n                    row.insert(\n                        field_name.clone(),\n                        eval_field(\n                            collection_relationships,\n                            &BTreeMap::new(),\n                            state,\n                            field,\n                            &old_row,\n                        )?,\n                    );\n                }\n            }\nOk\n(row)\n        })\n        .transpose()?;\nOk\n(models::MutationOperationResults {\n        affected_rows:\n1\n,\n        returning:\nSome\n(\nvec!\n[IndexMap::from_iter([(\n\"__value\"\n.into(),\n            models::RowFieldValue(serde_json::to_value(returning).map_err(|_| {\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    Json(models::ErrorResponse {\n                        message:\n\"cannot encode response\"\n.into(),\n                        details: serde_json::Value::Null,\n                    }),\n                )\n            })?),\n        )])]),\n    })\n}\n```",
    "files/ndc-spec/tutorial/mutations/index.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Mutations\n\nIn this section, we will break down the implementation of the `/mutation` endpoint.\n\nThe mutation endpoint is handled by the `post_mutation` function:\n\n```\nasync\nfn   post_mutation\n(\n    State(state): State<Arc<Mutex<AppState>>>,\n    Json(request): Json<models::MutationRequest>,\n) ->\nResult\n<Json<models::MutationResponse>> {\n```\n\nThis function receives the application state, and the[ MutationRequest ](../../reference/types.html#mutationrequest)structure.\n\nThe function iterates over the collection of requested[ MutationOperation ](../../reference/types.html#mutationoperation)structures, and handles each one in turn, adding each result to the `operation_results` field in the response:\n\n```\nlet\nmut\nstate = state.lock().\nawait\n;\nlet\nmut\noperation_results =\nvec!\n[];\nfor\noperation\nin\nrequest.operations.iter() {\nlet\noperation_result =\n            execute_mutation_operation(&\nmut\nstate, &request.collection_relationships, operation)?;\n        operation_results.push(operation_result);\n    }\nOk\n(Json(models::MutationResponse { operation_results }))\n}\n```\n\nThe `execute_mutation_operation` function is responsible for executing an individual operation. In the next section, we'll break that function down.",
    "files/ndc-spec/tutorial/mutations/operations.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Handling Operations\n\nThe `execute_mutation_operation` function is responsible for handling a single[ MutationOperation ](../../reference/types.html#mutationoperation), and returning the corresponding[ MutationOperationResults ](../../reference/types.html#mutationoperationresults):\n\n```\nfn   execute_mutation_operation\n(\n    state: &\nmut\nAppState,\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    operation: &models::MutationOperation,\n) ->\nResult\n<models::MutationOperationResults> {\nmatch\noperation {\n        models::MutationOperation::Procedure {\n            name,\n            arguments,\n            fields,\n        } => execute_procedure(state, name, arguments, fields, collection_relationships),\n    }\n}\n```\n\nThe function matches on the type of the operation, and delegates to the appropriate function. Currently, the only type of operation is `Procedure` , so the function delegates to the `execute_procedure` function. In the next section, we will break down the implementation of that function.",
    "files/ndc-spec/tutorial/queries/index.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Queries\n\nThe reference implementation of the `/query` endpoint may seem complicated, because there is a lot of functionality packed into a single endpoint. However, we will break the implementation down into small sections, each of which should be easily understood.\n\nWe start by looking at the type signature of the `post_query` function, which is the top-level function implementing the query endpoint:\n\n```\npub\nasync\nfn   post_query\n(\n    State(state): State<Arc<Mutex<AppState>>>,\n    Json(request): Json<models::QueryRequest>,\n) ->\nResult\n<Json<models::QueryResponse>> {\n```\n\nThis function accepts a[ QueryRequest ](../../reference/types.html#queryrequest)and must produce a[ QueryResponse ](../../reference/types.html#queryresponse).\n\nIn the next section, we will start to break down this problem step-by-step.",
    "files/ndc-spec/tutorial/queries/arguments.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Evaluating Arguments\n\nNow that we have reduced the problem to a single set of query variables, we must evaluate any[ collection arguments ](../../specification/queries/arguments.html), and in turn, evaluate the *collection* of rows that we will be working with.\n\nFrom there, we will be able to apply predicates, sort and paginate rows. But one step at a time!\n\nThe first step is to evaluate each argument, which the `execute_query_with_variables` function does by delegating to the `eval_argument` function:\n\n```\nfn   execute_query_with_variables\n(\n    collection: &\nstr\n,\n    arguments: &BTreeMap<\nString\n, models::Argument>,\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    query: &models::Query,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n) ->\nResult\n<models::RowSet> {\nlet\nmut\nargument_values = BTreeMap::new();\nfor\n(argument_name, argument_value)\nin\narguments.iter() {\nif\nargument_values\n            .insert(\n                argument_name.clone(),\n                eval_argument(variables, argument_value)?,\n            )\n            .is_some()\n        {\nreturn\nErr\n((\n                StatusCode::BAD_REQUEST,\n                Json(models::ErrorResponse {\n                    message:\n\"duplicate argument names\"\n.into(),\n                    details: serde_json::Value::Null,\n                }),\n            ));\n        }\n    }\nlet\ncollection = get_collection_by_name(collection, &argument_values, state)?;\n\n    execute_query(\n        collection_relationships,\n        variables,\n        state,\n        query,\n        Root::CurrentRow,\n        collection,\n    )\n}\n```\n\nOnce this is complete, and we have a collection of evaluated `argument_values` , we can delegate to the `get_collection_by_name` function. This function peforms the work of computing the full collection, by pattern matching on the name of the collection:\n\n```\nfn   get_collection_by_name\n(\n    collection_name: &\nstr\n,\n    arguments: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n) ->\nResult\n<\nVec\n<Row>> {\nmatch\ncollection_name {\n\"articles\"\n=>\nOk\n(state.articles.values().cloned().collect()),\n\"authors\"\n=>\nOk\n(state.authors.values().cloned().collect()),\n\"articles_by_author\"\n=> {\nlet\nauthor_id = arguments.get(\n\"author_id\"\n).ok_or((\n                StatusCode::BAD_REQUEST,\n                Json(models::ErrorResponse {\n                    message:\n\"missing argument author_id\"\n.into(),\n                    details: serde_json::Value::Null,\n                }),\n            ))?;\nlet\nauthor_id_int = author_id.as_i64().ok_or((\n                StatusCode::BAD_REQUEST,\n                Json(models::ErrorResponse {\n                    message:\n\"author_id must be a string\"\n.into(),\n                    details: serde_json::Value::Null,\n                }),\n            ))?;\nlet\nmut\narticles_by_author =\nvec!\n[];\nfor\n(_id, article)\nin\nstate.articles.iter() {\nlet\narticle_author_id = article.get(\n\"author_id\"\n).ok_or((\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    Json(models::ErrorResponse {\n                        message:\n\"author_id not found\"\n.into(),\n                        details: serde_json::Value::Null,\n                    }),\n                ))?;\nlet\narticle_author_id_int = article_author_id.as_i64().ok_or((\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    Json(models::ErrorResponse {\n                        message:\n\" \"\n.into(),\n                        details: serde_json::Value::Null,\n                    }),\n                ))?;\nif\narticle_author_id_int == author_id_int {\n                    articles_by_author.push(article.clone())\n                }\n            }\nOk\n(articles_by_author)\n        }\n\"latest_article_id\"\n=> {\nlet\nlatest_id = state\n                .articles\n                .iter()\n                .filter_map(|(_id, a)| a.get(\n\"id\"\n).and_then(|v| v.as_i64()))\n                .max();\nlet\nlatest_id_value = serde_json::to_value(latest_id).map_err(|_| {\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    Json(models::ErrorResponse {\n                        message:\n\" \"\n.into(),\n                        details: serde_json::Value::Null,\n                    }),\n                )\n            })?;\nOk\n(\nvec!\n[BTreeMap::from_iter([(\n\"__value\"\n.into(),\n                latest_id_value,\n            )])])\n        }\n        _ =>\nErr\n((\n            StatusCode::BAD_REQUEST,\n            Json(models::ErrorResponse {\n                message:\n\"invalid collection name\"\n.into(),\n                details: serde_json::Value::Null,\n            }),\n        )),\n    }\n}\n```\n\n *Note 1* : the `articles_by_author` collection is the only example here which has to apply any arguments. It is provided as an example of a collection which accepts an `author_id` argument, and it must validate that the argument is present, and that it is an integer.\n\n *Note 2* : the `latest_article_id` collection is provided as an example of a[ function ](../../specification/schema/functions.html). It is a collection like all the others, but must follow the rules for functions: it must consist of a single row, with a single column named `__value` .\n\nIn the next section, we will break down the implementation of `execute_query` .\nOnce we have computed the full collection, we can move onto evaluating the query in the context of that collection, using the `execute_query` function:\n\n```\nfn   execute_query\n(\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n    query: &models::Query,\n    root: Root,\n    collection:\nVec\n<Row>,\n) ->\nResult\n<models::RowSet> {\n```\n\nIn the next section, we will break down the implementation of `execute_query` .",
    "files/ndc-spec/tutorial/queries/variables.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Query Variables\n\nThe first step in `post_query` is to reduce the problem from a query with multiple sets of[ query variables ](../../specification/queries/variables.html)to only a single set.\n\nThe `post_query` function iterates over all variable sets, and for each one, produces a[ RowSet ](../../reference/types.html#rowset)of rows corresponding to that set of variables. Each `RowSet` is then added to the final `QueryResponse` :\n\n```\npub\nasync\nfn   post_query\n(\n    State(state): State<Arc<Mutex<AppState>>>,\n    Json(request): Json<models::QueryRequest>,\n) ->\nResult\n<Json<models::QueryResponse>> {\nlet\nstate = state.lock().\nawait\n;\nlet\nvariable_sets = request.variables.unwrap_or(\nvec!\n[BTreeMap::new()]);\nlet\nmut\nrow_sets =\nvec!\n[];\nfor\nvariables\nin\nvariable_sets.iter() {\nlet\nrow_set = execute_query_with_variables(\n            &request.collection,\n            &request.arguments,\n            &request.collection_relationships,\n            &request.query,\n            variables,\n            &state,\n        )?;\n        row_sets.push(row_set);\n    }\nOk\n(Json(models::QueryResponse(row_sets)))\n}\n```\n\nIn order to compute the `RowSet` for a given set of variables, the function delegates to a function named `execute_query_with_variables` :\n\n```\nfn   execute_query_with_variables\n(\n    collection: &\nstr\n,\n    arguments: &BTreeMap<\nString\n, models::Argument>,\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    query: &models::Query,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n) ->\nResult\n<models::RowSet> {\n```\n\nIn the next section, we will break down the implementation of this function.",
    "files/ndc-spec/tutorial/queries/execute/pagination.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Pagination\n\nOnce the irrelevant rows have been filtered out, the `execute_query` function applies the `limit` and `offset` arguments by calling the `paginate function:\n\n```\nlet\npaginated:\nVec\n<Row> = paginate(filtered.into_iter(), query.limit, query.offset);\n```\n\nThe `paginate` function is implemented using the `skip` and `take` functions on iterators:\n\n```\nfn   paginate\n<I:\nIterator\n<Item = Row>>(\n    collection: I,\n    limit:\nOption\n<\nu32\n>,\n    offset:\nOption\n<\nu32\n>,\n) ->\nVec\n<Row> {\nlet\nstart = offset.unwrap_or(\n0\n).try_into().unwrap();\nmatch\nlimit {\nSome\n(n) => collection.skip(start).take(n.try_into().unwrap()).collect(),\nNone\n=> collection.skip(start).collect(),\n    }\n}\n```",
    "files/ndc-spec/tutorial/queries/execute/sorting.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Sorting\n\nThe first step is to sort the rows in the full collection:\n\n```\nlet\nsorted = sort(\n        collection_relationships,\n        variables,\n        state,\n        collection,\n        &query.order_by,\n    )?;\n```\n\nThe[ Query ](../../../reference/types.html#query)object defines the sort order in terms of a list of[ OrderByElement ](../../../reference/types.html#orderbyelement)s. See the[ sorting specification ](../../../specification/queries/sorting.html)for details on how this ought to be interpreted.\n\n## The sort function\n\nThe `sort` function implements a simple insertion sort, computing the ordering for each pair of rows, and inserting each row at the correct place:\n\n```\nfn   sort\n(\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n    collection:\nVec\n<Row>,\n    order_by: &\nOption\n<models::OrderBy>,\n) ->\nResult\n<\nVec\n<Row>> {\nmatch\norder_by {\nNone\n=>\nOk\n(collection),\nSome\n(order_by) => {\nlet\nmut\ncopy =\nvec!\n[];\nfor\nitem_to_insert\nin\ncollection.into_iter() {\nlet\nmut\nindex =\n0\n;\nfor\nother\nin\ncopy.iter() {\nif\nlet\nOrdering::Greater = eval_order_by(\n                        collection_relationships,\n                        variables,\n                        state,\n                        order_by,\n                        other,\n                        &item_to_insert,\n                    )? {\nbreak\n;\n                    }\nelse\n{\n                        index +=\n1\n;\n                    }\n                }\n                copy.insert(index, item_to_insert);\n            }\nOk\n(copy)\n        }\n    }\n}\n```\n\n `sort` delegates to the `eval_order_by` function to compute the ordering between two rows:\n\n## Evaluating the Ordering\n\nTo compare two rows, the `eval_order_by` computes each `OrderByElement` in turn, and compares the rows in order, or in reverse order, depending on whether the ordering is *ascending* or *descending* .\n\nThe function returns the first `Ordering` which makes the two rows distinct (if any):\n\n```\nfn   eval_order_by\n(\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n    order_by: &models::OrderBy,\n    t1: &Row,\n    t2: &Row,\n) ->\nResult\n<Ordering> {\nlet\nmut\nresult = Ordering::Equal;\nfor\nelement\nin\norder_by.elements.iter() {\nlet\nv1 = eval_order_by_element(collection_relationships, variables, state, element, t1)?;\nlet\nv2 = eval_order_by_element(collection_relationships, variables, state, element, t2)?;\nlet\nx =\nmatch\nelement.order_direction {\n            models::OrderDirection::Asc => compare(v1, v2)?,\n            models::OrderDirection::Desc => compare(v2, v1)?,\n        };\n        result = result.then(x);\n    }\nOk\n(result)\n}\n```\n\nThe ordering for a single `OrderByElement` is computed by the `eval_order_by_element` function.\n\nWe won't cover every branch of this function in detail here, but it works by pattern matching on the type of ordering being used.\n\n### Ordering by a column\n\nAs an example, here is the function `eval_order_by_column` which evaluates *ordering by a column* :\n\n```\nfn   eval_order_by_column\n(\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n    item: &BTreeMap<\nString\n, serde_json::Value>,\n    path:\nVec\n<models::PathElement>,\n    name:\nString\n,\n) ->\nResult\n<serde_json::Value> {\nlet\nrows:\nVec\n<Row> = eval_path(collection_relationships, variables, state, &path, item)?;\nif\nrows.len() >\n1\n{\nreturn\nErr\n((\n            StatusCode::BAD_REQUEST,\n            Json(models::ErrorResponse {\n                message:\n\" \"\n.into(),\n                details: serde_json::Value::Null,\n            }),\n        ));\n    }\nmatch\nrows.first() {\nSome\n(row) => eval_column(row, name.as_str()),\nNone\n=>\nOk\n(serde_json::Value::Null),\n    }\n}\n```\n\nThis code computes the target table, possibly by traversing relationships using `eval_path` (we will cover this function later when we cover relationships), and validates that we computed a single row before selecting the value of the chosen column.\n\nNow that we have sorted the full collection, we can apply the predicate to filter down the collection of rows. We will cover this in the next section.",
    "files/ndc-spec/tutorial/queries/execute/aggregates.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Aggregates\n\nNow that we have computed the sorted, filtered, and paginated rows of the original collection, we can compute any aggregates over those rows.\n\nEach aggregate is computed in turn by the `eval_aggregate` function, and added to the list of all aggregates to return:\n\n```\nlet\naggregates = query\n        .aggregates\n        .as_ref()\n        .map(|aggregates| {\nlet\nmut\nrow: IndexMap<\nString\n, serde_json::Value> = IndexMap::new();\nfor\n(aggregate_name, aggregate)\nin\naggregates.iter() {\n                row.insert(\n                    aggregate_name.clone(),\n                    eval_aggregate(aggregate, &paginated)?,\n                );\n            }\nOk\n(row)\n        })\n        .transpose()?;\n```\n\nThe `eval_aggregate` function works by pattern matching on the type of the aggregate being computed:\n\n- A `star_count` aggregate simply counts all rows,\n- A `column_count` aggregate computes the subset of rows where the named column is non-null, and returns the count of only those rows,\n- A `single_column` aggregate is computed by delegating to the `eval_aggregate_function` function, which computes a custom aggregate operator over the values of the selected column taken from all rows.\n\n\n```\nfn   eval_aggregate\n(\n    aggregate: &models::Aggregate,\n    paginated: &\nVec\n<BTreeMap<\nString\n, serde_json::Value>>,\n) ->\nResult\n<serde_json::Value> {\nmatch\naggregate {\n        models::Aggregate::StarCount {} =>\nOk\n(serde_json::Value::from(paginated.len())),\n        models::Aggregate::ColumnCount { column, distinct } => {\nlet\nvalues = paginated\n                .iter()\n                .map(|row| {\n                    row.get(column).ok_or((\n                        StatusCode::BAD_REQUEST,\n                        Json(models::ErrorResponse {\n                            message:\n\"invalid column name\"\n.into(),\n                            details: serde_json::Value::Null,\n                        }),\n                    ))\n                })\n                .collect::<\nResult\n<\nVec\n<_>>>()?;\nlet\nnon_null_values = values.iter().filter(|value| !value.is_null());\nlet\nagg_value =\nif\n*distinct {\n                non_null_values\n                    .map(|value| {\n                        serde_json::to_string(value).map_err(|_| {\n                            (\n                                StatusCode::INTERNAL_SERVER_ERROR,\n                                Json(models::ErrorResponse {\n                                    message:\n\"unable to encode value\"\n.into(),\n                                    details: serde_json::Value::Null,\n                                }),\n                            )\n                        })\n                    })\n                    .collect::<\nResult\n<HashSet<_>>>()?\n                    .len()\n            }\nelse\n{\n                non_null_values.count()\n            };\n            serde_json::to_value(agg_value).map_err(|_| {\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    Json(models::ErrorResponse {\n                        message:\n\" \"\n.into(),\n                        details: serde_json::Value::Null,\n                    }),\n                )\n            })\n        }\n        models::Aggregate::SingleColumn { column, function } => {\nlet\nvalues = paginated\n                .iter()\n                .map(|row| {\n                    row.get(column).ok_or((\n                        StatusCode::BAD_REQUEST,\n                        Json(models::ErrorResponse {\n                            message:\n\"invalid column name\"\n.into(),\n                            details: serde_json::Value::Null,\n                        }),\n                    ))\n                })\n                .collect::<\nResult\n<\nVec\n<_>>>()?;\n            eval_aggregate_function(function, values)\n        }\n    }\n}\n```\n\nThe `eval_aggregate_function` function implements the custom aggregate operators `min` and `max` , which are provided for integer-valued columns:\n\n```\nfn   eval_aggregate_function\n(\n    function: &\nstr\n,\n    values:\nVec\n<&serde_json::Value>,\n) ->\nResult\n<serde_json::Value> {\nlet\nint_values = values\n        .iter()\n        .map(|value| {\n            value.as_i64().ok_or((\n                StatusCode::BAD_REQUEST,\n                Json(models::ErrorResponse {\n                    message:\n\"column is not an integer\"\n.into(),\n                    details: serde_json::Value::Null,\n                }),\n            ))\n        })\n        .collect::<\nResult\n<\nVec\n<_>>>()?;\nlet\nagg_value =\nmatch\nfunction {\n\"min\"\n=>\nOk\n(int_values.iter().min()),\n\"max\"\n=>\nOk\n(int_values.iter().max()),\n        _ =>\nErr\n((\n            StatusCode::BAD_REQUEST,\n            Json(models::ErrorResponse {\n                message:\n\"invalid aggregation function\"\n.into(),\n                details: serde_json::Value::Null,\n            }),\n        )),\n    }?;\n    serde_json::to_value(agg_value).map_err(|_| {\n        (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            Json(models::ErrorResponse {\n                message:\n\" \"\n.into(),\n                details: serde_json::Value::Null,\n            }),\n        )\n    })\n}\n```",
    "files/ndc-spec/tutorial/queries/execute/index.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Executing Queries\n\nIn this section, we will break down the implementation of the `execute_query` function:\n\n```\nfn   execute_query\n(\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n    query: &models::Query,\n    root: Root,\n    collection:\nVec\n<Row>,\n) ->\nResult\n<models::RowSet> {\n```\n\nAt this point, we have already computed the full collection, which is passed via the `collection` argument. Now, we need to evaluate the[ Query ](../../../reference/types.html#query)in the context of this collection.\n\nThe `Query` describes the predicate which should be applied to all rows, the sort order, pagination options, along with any aggregates to compute and fields to return.\n\nThe first step is to sort the collection.\n\n *Note* : we could also start by filtering, and then sort the filtered rows. Which is more efficient depends on the data and the query, and choosing between these approaches would be the job of a *query planner* in a real database engine. However, this is out of scope here, so we make an arbitrary choice, and sort the data first.",
    "files/ndc-spec/tutorial/queries/execute/relationships.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Relationships\n\nRelationships appear in many places in the[ QueryRequest ](../../../reference/types.html#queryrequest), but are always computed using the `eval_path` function.\n\n `eval_path` accepts a list of[ PathElement ](../../../reference/types.html#pathelement)s, each of which describes the traversal of a single edge of the collection-relationship graph. `eval_path` computes the collection at the final node of this path through the graph.\n\nIt does this by successively evaluating each edge in turn using the `eval_path_element` function:\n\n```\nfn   eval_path\n(\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n    path: &[models::PathElement],\n    item: &Row,\n) ->\nResult\n<\nVec\n<Row>> {\nlet\nmut\nresult:\nVec\n<Row> =\nvec!\n[item.clone()];\nfor\npath_element\nin\npath.iter() {\nlet\nrelationship_name = path_element.relationship.as_str();\nlet\nrelationship = collection_relationships.get(relationship_name).ok_or((\n            StatusCode::BAD_REQUEST,\n            Json(models::ErrorResponse {\n                message:\n\"invalid relationship name in path\"\n.into(),\n                details: serde_json::Value::Null,\n            }),\n        ))?;\n        result = eval_path_element(\n            collection_relationships,\n            variables,\n            state,\n            relationship,\n            &path_element.arguments,\n            &result,\n            &path_element.predicate,\n        )?;\n    }\nOk\n(result)\n}\n```\n\nThe `eval_path_element` function computes a collection from a single relationship, one source row at a time, by evaluating all relationship arguments, computing the target collection using `get_collection_by_name` , and evaluating any column mapping on any resulting rows:\n\n```\nfn   eval_path_element\n(\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n    relationship: &models::Relationship,\n    arguments: &BTreeMap<\nString\n, models::RelationshipArgument>,\n    source: &[Row],\n    predicate: &models::Expression,\n) ->\nResult\n<\nVec\n<Row>> {\nlet\nmut\nmatching_rows:\nVec\n<Row> =\nvec!\n[];\n// Note: Join strategy\n//\n// Rows can be related in two ways: 1) via a column mapping, and\n// 2) via collection arguments. Because collection arguments can be computed\n// using the columns on the source side of a relationship, in general\n// we need to compute the target collection once for each source row.\n// This join strategy can result in some target rows appearing in the\n// resulting row set more than once, if two source rows are both related\n// to the same target row.\n//\n// In practice, this is not an issue, either because a) the relationship\n// is computed in the course of evaluating a predicate, and all predicates are\n// implicitly or explicitly existentially quantified, or b) if the\n// relationship is computed in the course of evaluating an ordering, the path\n// should consist of all object relationships, and possibly terminated by a\n// single array relationship, so there should be no double counting.\nfor\nsrc_row\nin\nsource.iter() {\nlet\nmut\nall_arguments = BTreeMap::new();\nfor\n(argument_name, argument_value)\nin\nrelationship.arguments.iter() {\nif\nall_arguments\n                .insert(\n                    argument_name.clone(),\n                    eval_relationship_argument(variables, src_row, argument_value)?,\n                )\n                .is_some()\n            {\nreturn\nErr\n((\n                    StatusCode::BAD_REQUEST,\n                    Json(models::ErrorResponse {\n                        message:\n\"duplicate argument names\"\n.into(),\n                        details: serde_json::Value::Null,\n                    }),\n                ));\n            }\n        }\nfor\n(argument_name, argument_value)\nin\narguments.iter() {\nif\nall_arguments\n                .insert(\n                    argument_name.clone(),\n                    eval_relationship_argument(variables, src_row, argument_value)?,\n                )\n                .is_some()\n            {\nreturn\nErr\n((\n                    StatusCode::BAD_REQUEST,\n                    Json(models::ErrorResponse {\n                        message:\n\"duplicate argument names\"\n.into(),\n                        details: serde_json::Value::Null,\n                    }),\n                ));\n            }\n        }\nlet\ntarget = get_collection_by_name(\n            relationship.target_collection.as_str(),\n            &all_arguments,\n            state,\n        )?;\nfor\ntgt_row\nin\ntarget.iter() {\nif\neval_column_mapping(relationship, src_row, tgt_row)?\n                && eval_expression(\n                    collection_relationships,\n                    variables,\n                    state,\n                    predicate,\n                    tgt_row,\n                    tgt_row,\n                )?\n            {\n                matching_rows.push(tgt_row.clone());\n            }\n        }\n    }\nOk\n(matching_rows)\n}\n```",
    "files/ndc-spec/tutorial/queries/execute/filtering.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Filtering\n\nThe next step is to filter the rows based on the provided predicate expression:\n\n```\nlet\nfiltered:\nVec\n<Row> = (\nmatch\n&query.predicate {\nNone\n=>\nOk\n(sorted),\nSome\n(expr) => {\nlet\nmut\nfiltered:\nVec\n<Row> =\nvec!\n[];\nfor\nitem\nin\nsorted.into_iter() {\nlet\nroot =\nmatch\nroot {\n                    Root::CurrentRow => &item,\n                    Root::ExplicitRow(root) => root,\n                };\nif\neval_expression(\n                    collection_relationships,\n                    variables,\n                    state,\n                    expr,\n                    root,\n                    &item,\n                )? {\n                    filtered.push(item);\n                }\n            }\nOk\n(filtered)\n        }\n    })?;\n```\n\nAs we can see, the function delegates to the `eval_expression` function in order to evaluate the predicate on each row.\n\n## Evaluating expressions\n\nThe `eval_expression` function evaluates a predicate by pattern matching on the type of the expression `expr` , and returns a boolean value indicating whether the current row matches the predicate:\n\n```\nfn   eval_expression\n(\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n    expr: &models::Expression,\n    root: &Row,\n    item: &Row,\n) ->\nResult\n<\nbool\n> {\n```\n\n### Logical expressions\n\nThe first category of expression types are the *logical expressions* - *and* (conjunction), *or* (disjunction) and *not* (negation) - whose evaluators are straightforward:\n\n- To evaluate a conjunction/disjunction of subexpressions, we evaluate all of the subexpressions to booleans, and find the conjunction/disjunction of those boolean values respectively.\n- To evaluate the negation of a subexpression, we evaluate the subexpression to a boolean value, and negate the boolean.\n\n\n```\nmatch\nexpr {\n        models::Expression::And { expressions } => {\nfor\nexpr\nin\nexpressions.iter() {\nif\n!eval_expression(collection_relationships, variables, state, expr, root, item)? {\nreturn\nOk\n(\nfalse\n);\n                }\n            }\nOk\n(\ntrue\n)\n        }\n        models::Expression::Or { expressions } => {\nfor\nexpr\nin\nexpressions.iter() {\nif\neval_expression(collection_relationships, variables, state, expr, root, item)? {\nreturn\nOk\n(\ntrue\n);\n                }\n            }\nOk\n(\nfalse\n)\n        }\n        models::Expression::Not { expression } => {\nlet\nb = eval_expression(\n                collection_relationships,\n                variables,\n                state,\n                expression,\n                root,\n                item,\n            )?;\nOk\n(!b)\n        }\n```\n\n### Unary Operators\n\nThe next category of expressions are the *unary operators* . The only unary operator is the `IsNull` operator, which is evaluated by evaluating the operator's *comparison target* , and then comparing the result to `null` :\n\n```\nmodels::Expression::UnaryComparisonOperator { column, operator } =>\nmatch\noperator {\n            models::UnaryComparisonOperator::IsNull => {\nlet\nvals = eval_comparison_target(\n                    collection_relationships,\n                    variables,\n                    state,\n                    column,\n                    root,\n                    item,\n                )?;\nOk\n(vals.iter().any(|val| val.is_null()))\n            }\n        },\n```\n\nTo evaluate the comparison target, we delegate to the `eval_comparison_target` function, which pattern matches:\n\n- A column is evaluated using the `eval_path` function, which we will cover when we talk about[ relationships ](./relationships.html).\n- A *root collection* column (that is, a column from the *root collection* , or collection used by the nearest enclosing[ Query ](../../../reference/types.html#query)) is evaluated using `eval_column` . You may have noticed the additional argument, `root` , which has been passed down through every function call so far - this is to track the root collection for exactly this case.\n\n\n```\nfn   eval_comparison_target\n(\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n    target: &models::ComparisonTarget,\n    root: &Row,\n    item: &Row,\n) ->\nResult\n<\nVec\n<serde_json::Value>> {\nmatch\ntarget {\n        models::ComparisonTarget::Column { name, path } => {\nlet\nrows = eval_path(collection_relationships, variables, state, path, item)?;\nlet\nmut\nvalues =\nvec!\n[];\nfor\nrow\nin\nrows.iter() {\nlet\nvalue = eval_column(row, name.as_str())?;\n                values.push(value);\n            }\nOk\n(values)\n        }\n        models::ComparisonTarget::RootCollectionColumn { name } => {\nlet\nvalue = eval_column(root, name.as_str())?;\nOk\n(\nvec!\n[value])\n        }\n    }\n}\n```\n\n### Binary Operators\n\nThe next category of expressions are the *binary operators* . Binary operators can be *standard* or *custom* .\n\nThe only standard binary operators are the `equal` and `in` operators.\n\n `equal` evaluated by evaluating its *comparison target* and *comparison value* , and comparing them for equality:\n\n```\nmodels::Expression::BinaryComparisonOperator {\n            column,\n            operator,\n            value,\n        } =>\nmatch\noperator {\n            models::BinaryComparisonOperator::Equal => {\nlet\nleft_vals = eval_comparison_target(\n                    collection_relationships,\n                    variables,\n                    state,\n                    column,\n                    root,\n                    item,\n                )?;\nlet\nright_vals = eval_comparison_value(\n                    collection_relationships,\n                    variables,\n                    state,\n                    value,\n                    root,\n                    item,\n                )?;\nfor\nleft_val\nin\nleft_vals.iter() {\nfor\nright_val\nin\nright_vals.iter() {\nif\nleft_val == right_val {\nreturn\nOk\n(\ntrue\n);\n                        }\n                    }\n                }\nOk\n(\nfalse\n)\n            }\n```\n\nThe `in` operator is evaluated by evaluating its comparison target, and all of its comparison values, and testing whether the evaluated target appears in the list of evaluated values:\n\n```\nmodels::Expression::BinaryArrayComparisonOperator {\n            column,\n            operator,\n            values,\n        } =>\nmatch\noperator {\n            models::BinaryArrayComparisonOperator::In => {\nlet\nleft_vals = eval_comparison_target(\n                    collection_relationships,\n                    variables,\n                    state,\n                    column,\n                    root,\n                    item,\n                )?;\nfor\ncomparison_value\nin\nvalues.iter() {\nlet\nright_vals = eval_comparison_value(\n                        collection_relationships,\n                        variables,\n                        state,\n                        comparison_value,\n                        root,\n                        item,\n                    )?;\nfor\nleft_val\nin\nleft_vals.iter() {\nfor\nright_val\nin\nright_vals.iter() {\nif\nleft_val == right_val {\nreturn\nOk\n(\ntrue\n);\n                            }\n                        }\n                    }\n                }\nOk\n(\nfalse\n)\n            }\n        },\n```\n\nThe reference implementation provides a single custom binary operator as an example, which is the `like` operator on strings:\n\n```\nmodels::BinaryComparisonOperator::Other { name } =>\nmatch\nname.as_str() {\n\"like\"\n=> {\nlet\ncolumn_vals = eval_comparison_target(\n                        collection_relationships,\n                        variables,\n                        state,\n                        column,\n                        root,\n                        item,\n                    )?;\nlet\nregex_vals = eval_comparison_value(\n                        collection_relationships,\n                        variables,\n                        state,\n                        value,\n                        root,\n                        item,\n                    )?;\nfor\ncolumn_val\nin\ncolumn_vals.iter() {\nfor\nregex_val\nin\nregex_vals.iter() {\nlet\ncolumn_str = column_val.as_str().ok_or((\n                                StatusCode::BAD_REQUEST,\n                                Json(models::ErrorResponse {\n                                    message:\n\"column is not a string\"\n.into(),\n                                    details: serde_json::Value::Null,\n                                }),\n                            ))?;\nlet\nregex_str = regex_val.as_str().ok_or((\n                                StatusCode::BAD_REQUEST,\n                                Json(models::ErrorResponse {\n                                    message:\n\" \"\n.into(),\n                                    details: serde_json::Value::Null,\n                                }),\n                            ))?;\nlet\nregex = Regex::new(regex_str).map_err(|_| {\n                                (\n                                    StatusCode::BAD_REQUEST,\n                                    Json(models::ErrorResponse {\n                                        message:\n\"invalid regular expression\"\n.into(),\n                                        details: serde_json::Value::Null,\n                                    }),\n                                )\n                            })?;\nif\nregex.is_match(column_str) {\nreturn\nOk\n(\ntrue\n);\n                            }\n                        }\n                    }\nOk\n(\nfalse\n)\n                }\n                _ =>\nErr\n((\n                    StatusCode::BAD_REQUEST,\n                    Json(models::ErrorResponse {\n                        message:\n\" \"\n.into(),\n                        details: serde_json::Value::Null,\n                    }),\n                )),\n            },\n```\n\n### EXISTS expressions\n\nAn `EXISTS` expression is evaluated by recursively evaluating a `Query` on a related collection, and testing to see whether the resulting `RowSet` contains any rows:\n\n```\nmodels::Expression::Exists {\n            in_collection,\n            predicate,\n        } => {\nlet\nquery = models::Query {\n                aggregates:\nNone\n,\n                fields:\nSome\n(IndexMap::new()),\n                limit:\nNone\n,\n                offset:\nNone\n,\n                order_by:\nNone\n,\n                predicate:\nSome\n(*predicate.clone()),\n            };\nlet\ncollection = eval_in_collection(\n                collection_relationships,\n                item,\n                variables,\n                state,\n                in_collection,\n            )?;\nlet\nrow_set = execute_query(\n                collection_relationships,\n                variables,\n                state,\n                &query,\n                Root::ExplicitRow(root),\n                collection,\n            )?;\nlet\nrows:\nVec\n<IndexMap<_, _>> = row_set.rows.ok_or((\n                StatusCode::INTERNAL_SERVER_ERROR,\n                Json(models::ErrorResponse {\n                    message:\n\" \"\n.into(),\n                    details: serde_json::Value::Null,\n                }),\n            ))?;\nOk\n(!rows.is_empty())\n```",
    "files/ndc-spec/tutorial/queries/execute/field-selection.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Field Selection\n\nIn addition to computing aggregates, we can also return fields selected directly from the rows themselves.\n\nThis is done by mapping over the computed rows, and using the `eval_field` function to evaluate each selected field in turn:\n\n```\nlet\nrows = query\n        .fields\n        .as_ref()\n        .map(|fields| {\nlet\nmut\nrows:\nVec\n<IndexMap<\nString\n, models::RowFieldValue>> =\nvec!\n[];\nfor\nitem\nin\npaginated.iter() {\nlet\nmut\nrow = IndexMap::new();\nfor\n(field_name, field)\nin\nfields.iter() {\n                    row.insert(\n                        field_name.clone(),\n                        eval_field(collection_relationships, variables, state, field, item)?,\n                    );\n                }\n                rows.push(row)\n            }\nOk\n(rows)\n        })\n        .transpose()?;\n```\n\nThe `eval_field` function works by pattern matching on the field type:\n\n- A `column` is selected using the `eval_column` function,\n- A `relationship` field is selected by evaluating the related collection using `eval_path_element` (we will cover this in the next section), and then recursively executing a query using `execute_query` :\n\n\n```\nfn   eval_field\n(\n    collection_relationships: &BTreeMap<\nString\n, models::Relationship>,\n    variables: &BTreeMap<\nString\n, serde_json::Value>,\n    state: &AppState,\n    field: &models::Field,\n    item: &Row,\n) ->\nResult\n<models::RowFieldValue> {\nmatch\nfield {\n        models::Field::Column { column, .. } => {\nOk\n(models::RowFieldValue(eval_column(item, column.as_str())?))\n        }\n        models::Field::Relationship {\n            relationship,\n            arguments,\n            query,\n        } => {\nlet\nrelationship = collection_relationships.get(relationship.as_str()).ok_or((\n                StatusCode::BAD_REQUEST,\n                Json(models::ErrorResponse {\n                    message:\n\" \"\n.into(),\n                    details: serde_json::Value::Null,\n                }),\n            ))?;\nlet\nsource =\nvec!\n[item.clone()];\nlet\ncollection = eval_path_element(\n                collection_relationships,\n                variables,\n                state,\n                relationship,\n                arguments,\n                &source,\n                &models::Expression::And {\n                    expressions:\nvec!\n[],\n                },\n            )?;\nlet\nrows = execute_query(\n                collection_relationships,\n                variables,\n                state,\n                query,\n                Root::CurrentRow,\n                collection,\n            )?;\nlet\nrows_json = serde_json::to_value(rows).map_err(|_| {\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    Json(models::ErrorResponse {\n                        message:\n\"cannot encode rowset\"\n.into(),\n                        details: serde_json::Value::Null,\n                    }),\n                )\n            })?;\nOk\n(models::RowFieldValue(rows_json))\n        }\n    }\n}\n```",
    "files/ndc-spec/specification/versioning.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Versioning\n\nThis specification is versioned using semantic versioning, and a data connector claims compatibility with a[ semantic version ](https://semver.org)range via its[ capabilities ](capabilities.html)endpoint.\n\nNon-breaking changes to the specification may be achieved via the addition of new capabilities, which a connector will be assumed not to implement if the corresponding field is not present in its capabilities endpoint.",
    "files/ndc-spec/specification/explain.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Explain\n\nThe explain endpoint accepts a[ query ](./queries/README.html)request, but without actually executing the query, returns a representation of the *execution plan* .\n\n## Request\n\n`POST /explain`\n\n## Request\n\nSee[ QueryRequest ](../reference/types.html#queryrequest)\n\n## Response\n\nSee[ ExplainResponse ](../reference/types.html#explainresponse)",
    "files/ndc-spec/specification/basics.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Basics\n\nData connectors are implemented as HTTP services. To refer to a running data connector, it suffices to specify its base URL. All required endpoints are specified relative to this base URL.\n\nAll endpoints should accept JSON (in the case of POST request bodies) and return JSON using the `application/json` content type. The particular format of each JSON document will be specified for each endpoint.",
    "files/ndc-spec/specification/types.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Types\n\nSeveral definitions in this specification make mention of *types* . Types are used to categorize the sorts of data returned and accepted by a data connector.\n\nScalar and named object types are defined in the[ schema response\n ](./schema/README.html), and referred to by name at the point of use.\n\nArray types and nullable types are constructed at the point of use.\n\n## Named Types\n\nTo refer to a named (scalar or object) type, use the type `named` , and provide the name:\n\n```\n{\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"String\"\n}\n```\n\n## Array Types\n\nTo refer to an array type, use the type `array` , and refer to the type of the elements of the array in the `element_type` field:\n\n```\n{\n\"type\"\n:\n\"array\"\n,\n\"element_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"String\"\n}\n}\n```\n\n## Nullable Types\n\nTo refer to a nullable type, use the type `nullable` , and refer to the type of the underlying (non-null) inhabitants in the `underlying_type` field:\n\n```\n{\n\"type\"\n:\n\"nullable\"\n,\n\"underlying_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"String\"\n}\n}\n```\n\nNullable and array types can be nested. For example, to refer to a nullable array of nullable strings:\n\n```\n{\n\"type\"\n:\n\"nullable\"\n,\n\"underlying_type\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"element_type\"\n: {\n\"type\"\n:\n\"nullable\"\n,\n\"underlying_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"String\"\n}\n    }\n  }\n}\n```\n\n## See also\n\n- Type[ Type\n ](../reference/types.html#type)\n- [ Scalar types\n ](./schema/scalar-types.html)\n- [ Object types\n ](./schema/object-types.html)\n",
    "files/ndc-spec/specification/metrics.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Metrics\n\nData connectors should provide a **metrics endpoint** which reports relevant metrics in a textual format. Data connectors can report any metrics which are deemed relevant, or none at all, with the exception of any reserved keys.\n\n## Request\n\n`GET /metrics`\n\n## Response\n\nThe metrics endpoint should return a content type of `text/plain` , and return any metrics in the[ Prometheus textual format ](https://prometheus.io/docs/instrumenting/exposition_formats/#text-based-format).\n\n### Reserved keys\n\nMetric names prefixed with `hasura_` are reserved for future use, and should not be included in the response.\n\n## Example\n\n`# HELP query_total The number of /query requests served\n# TYPE query_total counter\nquery_total 10000 1685405427000\n# HELP mutation_total The number of /mutation requests served\n# TYPE mutation_total counter\nmutation_total 5000 1685405427000`",
    "files/ndc-spec/specification/error-handling.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Error Handling\n\n## Status Codes\n\nData connectors should use standard HTTP error codes to signal error conditions back to the Hasura server. In particular, the following error codes should be used in the indicated scenarios:\n\n| Response Code | Meaning | Used when |\n|---|---|---|\n| 200 | OK | The request was handled successfully according to this specification . |\n| 400 | Bad Request | The request did not match the data connector's expectation based on this specification. |\n| 403 | Forbidden | The request could not be handled because a permission check failed - for example, a mutation might fail because a check constraint was not met. |\n| 409 | Conflict | The request could not be handled because it would create a conflicting state for the data source - for example, a mutation might fail because a foreign key constraint was not met. |\n| 500 | Internal Server Error | The request could not be handled because of an error on the server |\n| 501 | Not Supported | The request could not be handled because it relies on an unsupported[ capability ](capabilities.html). *Note* : this ought to indicate an error on the *caller* side, since the caller should not generate requests which are incompatible with the indicated capabilities. |\n| 502 | Bad Gateway | The request could not be handled because an upstream service was unavailable or returned an unexpected response, e.g., a connection to a database server failed |\n\n\n## Response Body\n\nData connectors should return an[ ErrorResponse ](../reference/types.html#errorresponse)as JSON in the response body, in the case of an error.",
    "files/ndc-spec/specification/index.html.md": "# Hasura Data Connectors Developer's Guide\n\n# API Specification\n\n| Version |\n|---|\n|  `0.1.0`  |\n\n\nA data connector encapsulates a data source by implementing the protocol in this specification.\n\nA data connector must implement several web service endpoints:\n\n- A **capabilities** endpoint, which describes which features the data source is capable of implementing.\n- A **schema** endpoint, which describes the resources provided by the data source, and the shape of the data they contain.\n- A **query** endpoint, which reads data from one of the relations described by the schema endpoint.\n- A **mutation** endpoint, which modifies the data in one of the relations described by the schema endpoint.\n- An **explain** endpoint, which explains a query plan, without actually executing it.\n- A **metrics** endpoint, which exposes runtime metrics about the data connector.\n",
    "files/ndc-spec/specification/changelog.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Changelog\n\n## 0.1.0\n\n### Terminology\n\nTables are now known as *collections* .\n\n### Collection Names\n\nCollection names are now single strings instead of arrays of strings. The array structure was previously used to represent qualification by a schema or database name, but the structure was not used anywhere on the client side, and had no semantic meaning. GDC now abstracts over these concepts, and expects relations to be named by strings.\n\n### No Configuration\n\nThe configuration header convention was removed. Connectors are now expected to manage their own configuration, and a connector URL fully represents that connector with its pre-specified configuration.\n\n### No Database Concepts in GDC\n\nGDC no longer sends any metadata to indicate database-specific concepts. For example, a Collection used to indicate whether it was a Collection or view. Such metadata would be passed back in the query IR, to help the connector disambiguate which database object to query. When we proposed adding functions, we would have had to add a new type to disambiguate nullary functions from collections, etc. Instead, we now expect connectors to understand their own schema, and understand the query IR that they receive, as long as it is compatible with their GDC schema.\n\nColumn types are no longer sent in the query and mutation requests.\n\nTables, views and functions are unified under a single concept called \"collections\". GDC does not care how queries and mutations on relations are implemented.\n\n### Collection Arguments\n\nCollection arguments were added to relations in order to support use cases like table-valued functions and certain REST endpoints. Relationships can determine collection arguments.\n\n### Functions\n\nCollections which return a single column and a single row are also called \"functions\", and identified separately in the schema response.\n\n### Field Arguments\n\nField arguments were added to fields in order to support use cases like computed fields.\n\n### Operators\n\nThe equality operator is now expected on every scalar type implicitly.\n\n *Note* : it was already implicitly supported by any connector advertising the `variables` capability, which imposes column equality constraints in each row set fetched in a forall query.\n\nThe equality operator will have semantics assigned for the purposes of testing.\n\nScalars can define additional operators, whose semantics are opaque.\n\n### Procedures\n\nProceduress were added to the list of available mutation operation types\n\n### Schema\n\n- Scalar types were moved to the schema endpoint\n- The `object_types` field was added to the schema endpoint\n\n\n### Raw Queries\n\nThe raw query endpoint was removed, since it cannot be given any useful semantics across all implementations.\n\n### Datasets\n\nThe datasets endpoints were removed from the specification, because there was no way to usefully use it without prior knowledge of its implementation.",
    "files/ndc-spec/specification/capabilities.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Capabilities\n\nThe capabilities endpoint provides metadata about the features which the data connector (and data source) support.\n\n## Request\n\n`GET /capabilities`\n\n## Response\n\nSee[ CapabilitiesResponse ](../reference/types.html#capabilitiesresponse)\n\n### Example\n\n```\n{\n\"versions\"\n:\n\"^0.1.0\"\n,\n\"capabilities\"\n: {\n\"query\"\n: {\n\"aggregates\"\n: {},\n\"variables\"\n: {}\n    },\n\"relationships\"\n: {\n\"relation_comparisons\"\n: {},\n\"order_by_aggregate\"\n: {}\n    }\n  }\n}\n```\n\n## Response Fields\n\n| Name | Description |\n|---|---|\n|  `versions`  | A[ semantic versioning ](https://semver.org)range of API versions which the data connector |\n|  `capabilities.explain`  | Whether the data connector is capable of describing query plans |\n|  `capabilities.query.aggregates`  | Whether the data connector supports[ aggregate queries ](queries/aggregates.html) |\n|  `capabilities.query.variables`  | Whether the data connector supports[ queries with variables ](queries/variables.html) |\n|  `capabilities.relationships`  | Whether the data connector supports[ relationships ](queries/relationships.html) |\n|  `capabilities.relationships.order_by_aggregate`  | Whether order by clauses can include aggregates |\n|  `capabilities.relationships.relation_comparisons`  | Whether comparisons can include columns reachable via[ relationships ](queries/relationships.html) |\n\n\n## See also\n\n- Type[ Capabilities ](../reference/types.html#capabilities)\n- Type[ CapabilitiesResponse ](../reference/types.html#capabilitiesresponse)\n- Type[ QueryCapabilities ](../reference/types.html#querycapabilities)\n",
    "files/ndc-spec/specification/telemetry.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Telemetry\n\nHasura uses OpenTelemetry to coordinate the collection of traces and metrics with data connectors.\n\n## Trace Collection\n\nTrace collection is out of the scope of this specification currently. This may change in a future revision.\n\n## Trace Propagation\n\nHasura uses the[ W3C TraceContext specification ](https://www.w3.org/TR/trace-context/)to implement trace propagation. Data connectors should propagate tracing headers in this format to any downstream services.",
    "files/ndc-spec/specification/health.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Service Health\n\nData connectors should provide a **health endpoint** which can be used to indicate service health and readiness to any client applications.\n\n## Request\n\n`GET /healthz`\n\n## Response\n\nIf the data connector is available and ready to accept requests, then the health endpoint should return status code `204 No Content` .\n\nOtherwise, it should ideally return a status code `503 Service Unavailable` , or some other appropriate HTTP error code.",
    "files/ndc-spec/specification/mutations/procedures.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Procedures\n\nA procedure which is[ described in the schema ](../schema/procedures.html)can be invoked using a[ MutationOperation ](../../reference/types.html#mutationoperation).\n\nThe operation should specify the procedure name, any arguments, and a list of[ Field ](../../reference/types.html#field)s to be returned.\n\n## Requirements\n\n- The `affected_rows` field in the corresponding[ MutationOperationResults ](../../reference/types.html#mutationoperationresults)structure should indicate the number of rows in the data source which were modified as a result of the operation.\n- The `returning` field in the corresponding[ MutationOperationResults ](../../reference/types.html#mutationoperationresults)structure should contain a single row, with a single column named `__value` . That column should contain the result of the operation, which has a value compatible with the return type of the procedure.\n",
    "files/ndc-spec/specification/mutations/index.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Mutations\n\nThe mutation endpoint accepts a mutation request, containing a collection of mutation operations to be performed in the context the data source, and returns a response containing a result for each operation.\n\nThe structure and requirements for specific fields listed below will be covered in subsequent chapters.\n\n## Request\n\n`POST /mutation`\n\n## Request\n\nSee[ MutationRequest ](../../reference/types.html#mutationrequest)\n\n## Request Fields\n\n| Name | Description |\n|---|---|\n|  `operations`  | A list of mutation operations to perform |\n|  `collection_relationships`  | Any[ relationships ](../queries/relationships.html)between collections involved in the mutation request |\n\n\n## Mutation Operations\n\nEach operation is described by a[ MutationOperation ](../../reference/types.html#mutationoperation)structure, which can be one of several types. However, currently[ procedures ](./procedures.html)are the only supported operation type.\n\n## Response\n\nSee[ MutationResponse ](../../reference/types.html#mutationresponse)\n\n## Requirements\n\n- The `operation_results` field of the[ MutationResponse ](../../reference/types.html#mutationresponse)should contain one[ MutationOperationResults ](../../reference/types.html#mutationoperationresults)structure for each requested operation in the[ MutationRequest ](../../reference/types.html#mutationrequest).\n- Each[ MutationOperationResults ](../../reference/types.html#mutationoperationresults)structure should indicate the number of affected rows, along with a list of those rows.\n",
    "files/ndc-spec/specification/queries/pagination.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Pagination\n\nThe `limit` and `offset` parameters on the[ Query ](../../reference/types.html#query)object control pagination:\n\n- `limit` specifies the maximum number of rows to return from a query in the rows property. `limit` does not influence the rows considered by aggregations.\n- `offset` : The index of the first row to return. This affects the rows returned, and also the rows considered by aggregations.\n\n\n## Requirements\n\n- If `limit` is specified, the response should contain at most that many rows.\n\n\n## See also\n\n- Type[ Query ](../../reference/types.html#query)\n",
    "files/ndc-spec/specification/queries/sorting.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Sorting\n\nA[ Query ](../../reference/types.html#query)can specify how rows should be sorted in the response.\n\nThe requested ordering can be found in the `order_by` field of the[ Query ](../../reference/types.html#query)object.\n\n## Computing the Ordering\n\nTo compute the ordering from the `order_by` field, data connectors should implement the following ordering between rows:\n\n- Consider each element of the `order_by.elements` array in turn.\n- For each[ OrderByElement ](../../reference/types.html#orderbyelement):\n    - If `element.target.type` is `column` , then to compare two rows, compare the value in the selected column. See type `column` below.\n\n- If `element.target.type` is `star_count_aggregate` , compare two rows by comparing the row count of a related collection. See type `star_count_aggregate` below.\n\n- If `element.target.type` is `single_column_aggregate` , compare two rows by comparing a single column aggregate. See type `single_column_aggregate` below.\n\n\n### Type column\n\nIf `element.order_direction` is `asc` , then the row with the smaller column comes first.\n\nIf `element.order_direction` is `asc` , then the row with the smaller column comes second.\n\nIf the column values are incomparable, continue to the next[ OrderByElement ](../../reference/types.html#orderbyelement).\n\nThe data connector should document, for each scalar type, a comparison function to use for any two values of that scalar type.\n\nFor example, a data connector might choose to use the obvious ordering for a scalar integer-valued type, but to use the database-given ordering for a string-valued type, based on a certain choice of collation.\n\nFor example, the following `query` requests that a collection of articles be ordered by `title` descending:\n\n```\n{\n\"collection\"\n:\n\"articles\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n        },\n\"order_by\"\n: {\n\"elements\"\n: [\n                {\n\"target\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"title\"\n,\n\"path\"\n: []\n                    },\n\"order_direction\"\n:\n\"desc\"\n}\n            ]\n        }\n    },\n\"collection_relationships\"\n: {}\n}\n```\n\nThe selected column can be chosen from a related collection by specifying the `path` property. `path` consists of a list of named[ relationships ](./relationships.html).\n\nFor example, this query sorts articles by their author's last names, and then by their first names, by traversing the relationship from articles to authors:\n\n```\n{\n\"collection\"\n:\n\"articles\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n},\n\"author\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"article_author\"\n,\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n}\n                    }\n                }\n            }\n        },\n\"order_by\"\n: {\n\"elements\"\n: [\n                {\n\"target\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"last_name\"\n,\n\"path\"\n: [\n                            {\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"article_author\"\n,\n\"predicate\"\n: {\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: []\n                                }\n                            }\n                        ]\n                    },\n\"order_direction\"\n:\n\"asc\"\n},\n                {\n\"target\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"first_name\"\n,\n\"path\"\n: [\n                            {\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"article_author\"\n,\n\"predicate\"\n: {\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: []\n                                }\n                            }\n                        ]\n                    },\n\"order_direction\"\n:\n\"asc\"\n}\n            ]\n        }\n    },\n\"collection_relationships\"\n: {\n\"article_author\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {\n\"author_id\"\n:\n\"id\"\n},\n\"relationship_type\"\n:\n\"object\"\n,\n\"source_collection_or_type\"\n:\n\"article\"\n,\n\"target_collection\"\n:\n\"authors\"\n}\n    }\n}\n```\n\n### Type star_count_aggregate\n\nAn ordering of type `star_count_aggregate` orders rows by a count of rows in some[ related collection ](./relationships.html). If the respective counts are incomparable, the ordering should continue to the next[ OrderByElement ](../../reference/types.html#orderbyelement).\n\nFor example, this query sorts article authors by their total article count:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles_aggregate\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"aggregates\"\n: {\n\"count\"\n: {\n\"type\"\n:\n\"star_count\"\n}\n                    }\n                }\n            }\n        },\n\"order_by\"\n: {\n\"elements\"\n: [\n                {\n\"order_direction\"\n:\n\"desc\"\n,\n\"target\"\n: {\n\"type\"\n:\n\"star_count_aggregate\"\n,\n\"path\"\n: [\n                            {\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"predicate\"\n: {\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: []\n                                }\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {\n\"id\"\n:\n\"author_id\"\n},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles\"\n}\n    }\n}\n```\n\n### Type single_column_aggregate\n\nAn ordering of type `single_column_aggregate` orders rows by an aggregate computed over rows in some[ related collection ](./relationships.html). If the respective aggregates are incomparable, the ordering should continue to the next[ OrderByElement ](../../reference/types.html#orderbyelement).\n\nFor example, this query sorts article authors by their maximum article ID:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles_aggregate\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"aggregates\"\n: {\n\"max_id\"\n: {\n\"type\"\n:\n\"single_column\"\n,\n\"column\"\n:\n\"id\"\n,\n\"function\"\n:\n\"max\"\n}\n                    }\n                }\n            }\n        },\n\"order_by\"\n: {\n\"elements\"\n: [\n                {\n\"order_direction\"\n:\n\"asc\"\n,\n\"target\"\n: {\n\"type\"\n:\n\"single_column_aggregate\"\n,\n\"column\"\n:\n\"id\"\n,\n\"function\"\n:\n\"max\"\n,\n\"path\"\n: [\n                            {\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"predicate\"\n: {\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: []\n                                }\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {\n\"id\"\n:\n\"author_id\"\n},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles\"\n}\n    }\n}\n```\n\n## Requirements\n\n- Rows in the response should be ordered according to the algorithm described above.\n- The `order_by` field should not affect the set of collection which are returned, except for their order.\n- If the `order_by` field is not provided then rows should be returned in an unspecified but deterministic order. For example, an implementation might choose to return rows in the order of their primary key or creation timestamp by default.\n\n\n## See also\n\n- Type[ OrderBy ](../../reference/types.html#orderby)\n- Type[ OrderByElement ](../../reference/types.html#orderbyelement)\n- Type[ OrderByTarget ](../../reference/types.html#orderbytarget)\n",
    "files/ndc-spec/specification/queries/aggregates.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Aggregates\n\nIn addition to fetching multiple rows of raw data from a collection, the query API supports fetching aggregated data.\n\nAggregates are requested in the `aggregates` field of the[ Query ](../../reference/types.html#query)object.\n\nThere are three types of aggregate:\n\n- `single_column` aggregates apply an aggregation function (as defined by the column's[ scalar type ](../schema/scalar-types.html)in the schema response) to a column,\n- `column_count` aggregates count the number of rows with non-null values in the specified columns. If the `distinct` flag is set, then the count should only count unique non-null values of those columns,\n- `star_count` aggregates count all matched rows.\n\n\n## Example\n\nThe following query object requests the aggregated sum of all order totals, along with the count of all orders, and the count of all orders which have associated invoices (via the nullable `invoice_id` column):\n\n```\n{\n\"collection\"\n: [\n\"orders\"\n],\n\"collection_relationships\"\n: {},\n\"query\"\n: {\n\"aggregates\"\n: {\n\"orders_total\"\n: {\n\"type\"\n:\n\"single_column\"\n,\n\"function\"\n:\n\"sum\"\n,\n\"column\"\n:\n\"total\"\n},\n\"invoiced_orders_count\"\n: {\n\"type\"\n:\n\"column_count\"\n,\n\"columns\"\n: [\n\"invoice_id\"\n]\n      },\n\"orders_count\"\n: {\n\"type\"\n:\n\"star_count\"\n}\n    }\n  }\n}\n```\n\nIn this case, the query has no predicate function, so all three aggregates would be computed over all rows.\n\n## Requirements\n\n- Each aggregate should be computed over all rows that match the `Query` .\n- Each requested aggregate must be returned in the `aggregates` property on the[ QueryResponse ](../../reference/types.html#queryresponse)object, using the same key as used to request it.\n\n\n## See also\n\n- Type[ Aggregate ](../../reference/types.html#aggregate)\n",
    "files/ndc-spec/specification/queries/index.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Queries\n\nThe query endpoint accepts a query request, containing expressions to be evaluated in the context the data source, and returns a response consisting of relevant rows of data.\n\nThe structure and requirements for specific fields listed below will be covered in subsequent chapters.\n\n## Request\n\n`POST /query`\n\n## Request\n\nSee[ QueryRequest ](../../reference/types.html#queryrequest)\n\n## Request Fields\n\n| Name | Description |\n|---|---|\n|  `collection`  | The name of a collection to query |\n|  `query`  | The query syntax tree |\n|  `arguments`  | Values to be provided to any top-level[ collection arguments ](./arguments.html) |\n|  `collection_relationships`  | Any[ relationships ](./relationships.html)between collections involved in the query request |\n|  `variables`  | One set of[ named variables ](./variables.html)for each rowset to fetch. Each variable set should be subtituted in turn, and a fresh set of rows returned. |\n\n\n## Response\n\nSee[ QueryResponse ](../../reference/types.html#queryresponse)\n\n## Requirements\n\n- If the request specifies `variables` , then the response must contain one[ RowSet ](../../reference/types.html#rowset)for each collection of variables provided. If not, the data connector should respond as if `variables` were set to a single empty collection of variables: `[{}]` .\n- If the request specifies `fields` , then the response must contain `rows` according to the[ schema ](../schema/README.html)advertised for the requested `collection` .\n- If the request specifies `aggregates` then the response must contain `aggregates` , with one response key per requested aggregate, using the same keys. See[ aggregates ](./aggregates.html).\n- If the request specifies `arguments` , then the implementation must validate the provided arguments against the types specified by the collection's[ schema ](../schema/README.html). See[ arguments ](./arguments.html).\n",
    "files/ndc-spec/specification/queries/relationships.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Relationships\n\nQueries can request data from other collections via relationships. A relationship identifies rows in one collection (the \"source collection\") with possibly-many related rows in a second collection (the \"target collection\") in two ways:\n\n- Columns in the two collections can be related via *column mappings* , and\n- [ Collection arguments ](./arguments.html)to the target collection can be computed via the row of the source collection.\n\n\n## Defining Relationships\n\nRelationships are defined (and given names) in the top-level `QueryRequest` object, and then referred to by name everywhere they are used. To define a relationship, add a[ Relationship ](../../reference/types.html#relationship)object to the `collection_relationships` property of the `QueryRequest` object.\n\n## Column Mappings\n\nA column mapping is a set of pairs of columns - each consisting of one column from the source collection and one column from the target collection - which must be pairwise equal in order for a pair of rows to be considered equal.\n\nFor example, we can fetch each `author` with its list of related `articles` by establishing a column mapping between the author's primary key and the article's `author_id` column:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n                    }\n                }\n            }\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {\n\"id\"\n:\n\"author_id\"\n},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles\"\n}\n    }\n}\n```\n\n## Collection Arguments\n\nSee[ collection arguments ](./arguments.html)for examples.\n\n## Advanced relationship use cases\n\nRelationships are not used only for fetching data - they are used in practically all features of data connectors, as we will see below.\n\n### Relationships in predicates\n\nFilters can reference columns across relationships. For example, here we fetch all authors who have written articles with the word `\"Functional\"` in the title:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n                    }\n                }\n            }\n        },\n\"where\"\n: {\n\"type\"\n:\n\"binary_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"title\"\n,\n\"path\"\n: [{\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"predicate\"\n: {\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: []\n                    }\n                }]\n            },\n\"operator\"\n: {\n\"type\"\n:\n\"other\"\n,\n\"name\"\n:\n\"like\"\n},\n\"value\"\n: {\n\"type\"\n:\n\"scalar\"\n,\n\"value\"\n:\n\"Functional\"\n}\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {\n\"id\"\n:\n\"author_id\"\n},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles\"\n}\n    }\n}\n```\n\n `EXISTS` expressions in predicates can query related collections. Here we find all authors who have written any article with `\"Functional\"` in the title:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n                    }\n                }\n            }\n        },\n\"where\"\n: {\n\"type\"\n:\n\"exists\"\n,\n\"in_collection\"\n: {\n\"type\"\n:\n\"related\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n},\n\"where\"\n: {\n\"type\"\n:\n\"binary_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"title\"\n,\n\"path\"\n: []\n                },\n\"operator\"\n: {\n\"type\"\n:\n\"other\"\n,\n\"name\"\n:\n\"like\"\n},\n\"value\"\n: {\n\"type\"\n:\n\"scalar\"\n,\n\"value\"\n:\n\"Functional\"\n}\n            }\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {\n\"id\"\n:\n\"author_id\"\n},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles\"\n}\n    }\n}\n```\n\n### Relationships in order_by\n\nSorting can be defined in terms of row counts and aggregates over related collections.\n\nFor example, here we order authors by the number of articles they have written:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles_aggregate\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"aggregates\"\n: {\n\"count\"\n: {\n\"type\"\n:\n\"star_count\"\n}\n                    }\n                }\n            }\n        },\n\"order_by\"\n: {\n\"elements\"\n: [\n                {\n\"order_direction\"\n:\n\"desc\"\n,\n\"target\"\n: {\n\"type\"\n:\n\"star_count_aggregate\"\n,\n\"path\"\n: [\n                            {\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"predicate\"\n: {\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: []\n                                }\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {\n\"id\"\n:\n\"author_id\"\n},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles\"\n}\n    }\n}\n```\n\nWe can also order by custom aggregate functions applied to related collections. For example, here we order authors by their most recent (maximum) article ID:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles_aggregate\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"aggregates\"\n: {\n\"max_id\"\n: {\n\"type\"\n:\n\"single_column\"\n,\n\"column\"\n:\n\"id\"\n,\n\"function\"\n:\n\"max\"\n}\n                    }\n                }\n            }\n        },\n\"order_by\"\n: {\n\"elements\"\n: [\n                {\n\"order_direction\"\n:\n\"asc\"\n,\n\"target\"\n: {\n\"type\"\n:\n\"single_column_aggregate\"\n,\n\"column\"\n:\n\"id\"\n,\n\"function\"\n:\n\"max\"\n,\n\"path\"\n: [\n                            {\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"predicate\"\n: {\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: []\n                                }\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {\n\"id\"\n:\n\"author_id\"\n},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles\"\n}\n    }\n}\n```",
    "files/ndc-spec/specification/queries/arguments.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Arguments\n\n *Collection arguments* parameterize an entire collection, and must be provided in queries wherever the collection is referenced, either directly, or via relationships,\n\n## Collection Arguments\n\nCollection arguments should be provided in the `QueryRequest` anywhere a collection is referenced. The set of provided arguments should be compatible with the list of arguments required by the corresponding[ collection in the schema response ](../schema/collections.html).\n\n### Specifying arguments to the top-level collection\n\nCollection arguments should be provided as key-value pairs in the `arguments` property of the top-level `QueryRequest` object:\n\n```\n{\n\"collection\"\n:\n\"articles_by_author\"\n,\n\"arguments\"\n: {\n\"author_id\"\n: {\n\"type\"\n:\n\"literal\"\n,\n\"value\"\n:\n1\n}\n    },\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n        }\n    },\n\"collection_relationships\"\n: {}\n}\n```\n\n### Relationships\n\n[ Relationships ](./relationships.html)can specify values for arguments on their target collection:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n                    }\n                }\n            }\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {\n\"author_id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"id\"\n}\n            },\n\"column_mapping\"\n: {\n            },\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles_by_author\"\n}\n    }\n}\n```\n\nAny arguments which are not defined by the relationship itself should be specified where the relationship is used. For example, here the `author_id` argument can be moved from the relationship definition to the field which uses it:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {\n\"author_id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"id\"\n}\n                },\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n                    }\n                }\n            }\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles_by_author\"\n}\n    }\n}\n```\n\n### Collection arguments in predicates\n\nArguments must be specified in predicates whenever a reference to a secondary collection is required.\n\nFor example, in an `EXISTS` expression, if the target collection has arguments:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n}\n        },\n\"where\"\n: {\n\"type\"\n:\n\"exists\"\n,\n\"in_collection\"\n: {\n\"type\"\n:\n\"related\"\n,\n\"arguments\"\n: {\n\"author_id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"id\"\n}\n                },\n\"relationship\"\n:\n\"author_articles\"\n},\n\"where\"\n: {\n\"type\"\n:\n\"binary_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"title\"\n,\n\"path\"\n: []\n                },\n\"operator\"\n: {\n\"type\"\n:\n\"other\"\n,\n\"name\"\n:\n\"like\"\n},\n\"value\"\n: {\n\"type\"\n:\n\"scalar\"\n,\n\"value\"\n:\n\"Functional\"\n}\n            }\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles_by_author\"\n}\n    }\n}\n```\n\nOr when a predicate expression matches a column from a related collection:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n}\n        },\n\"where\"\n: {\n\"type\"\n:\n\"binary_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"title\"\n,\n\"path\"\n: [\n                    {\n\"arguments\"\n: {\n\"author_id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"id\"\n}\n                        },\n\"relationship\"\n:\n\"author_articles\"\n,\n\"predicate\"\n: {\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: []\n                        }\n                    }\n                ]\n            },\n\"operator\"\n: {\n\"type\"\n:\n\"other\"\n,\n\"name\"\n:\n\"like\"\n},\n\"value\"\n: {\n\"type\"\n:\n\"scalar\"\n,\n\"value\"\n:\n\"Functional\"\n}\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles_by_author\"\n}\n    }\n}\n```\n\n### Collection arguments in order_by\n\nArguments must be specified when an `OrderByElement` references a related collection.\n\nFor example, when ordering by an aggregate of rows in a related collection, and that collection has arguments:\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n}\n        },\n\"order_by\"\n: {\n\"elements\"\n: [\n                {\n\"order_direction\"\n:\n\"desc\"\n,\n\"target\"\n: {\n\"type\"\n:\n\"star_count_aggregate\"\n,\n\"path\"\n: [\n                            {\n\"arguments\"\n: {\n\"author_id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"id\"\n}\n                                },\n\"relationship\"\n:\n\"author_articles\"\n,\n\"predicate\"\n: {\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: []\n                                }\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles_by_author\"\n}\n    }\n}\n```",
    "files/ndc-spec/specification/queries/filtering.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Filtering\n\nA[ Query ](../../reference/types.html#query)can specify a predicate expression which should be used to filter rows in the response.\n\nA predicate expression can be one of\n\n- An application of a *comparison operator* to a column and a value, or\n- An `EXISTS` expression, or\n- A *conjunction* of other expressions, or\n- A *disjunction* of other expressions, or\n- A *negation* of another expression\n\n\nThe predicate expression is specified in the `predicate` field of the[ Query ](../../reference/types.html#query)object.\n\n## Comparison Operators\n\n### Unary Operators\n\nUnary comparison operators are denoted by expressions with a `type` field of `unary_comparison_operator` .\n\nThe only supported unary operator currently is `is_null` , which return `true` when a column value is `null` :\n\n```\n{\n\"type\"\n:\n\"unary_comparison_operator\"\n,\n\"operator\"\n:\n\"is_null\"\n,\n\"column\"\n: {\n\"name\"\n:\n\"title\"\n}\n}\n```\n\n### Binary Operators\n\nBinary comparison operators are denoted by expressions with a `type` field of `binary_comparison_operator` .\n\nThe set of available operators depends on the type of the column involved in the expression. The `equal` operator should be implemented for all types of columns.\n\nSee type[ BinaryComparisonOperator ](../../reference/types.html#binarycomparisonoperator).\n\n#### equals\n\n `equals` tests if a column value is equal to a scalar value, another column value, or a variable.\n\nSee type[ ComparisonValue ](../../reference/types.html#comparisonvalue)for the valid inhabitants of the `value` field.\n\n```\n{\n\"collection\"\n:\n\"articles\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n        },\n\"where\"\n: {\n\"type\"\n:\n\"binary_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"id\"\n,\n\"path\"\n: []\n            },\n\"operator\"\n: {\n\"type\"\n:\n\"equal\"\n},\n\"value\"\n: {\n\"type\"\n:\n\"scalar\"\n,\n\"value\"\n:\n1\n}\n        }\n    },\n\"collection_relationships\"\n: {}\n}\n```\n\n### Custom Binary Comparison Operators\n\nData connectors can also extend the expression grammar by defining comparison operators on each[ scalar type ](../schema/scalar-types.html)in the schema response.\n\nFor example, here is an expression which uses a custom `like` operator provided on the `String` type in the reference implementation:\n\n```\n{\n\"collection\"\n:\n\"articles\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n        },\n\"where\"\n: {\n\"type\"\n:\n\"binary_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"title\"\n,\n\"path\"\n: []\n            },\n\"operator\"\n: {\n\"type\"\n:\n\"other\"\n,\n\"name\"\n:\n\"like\"\n},\n\"value\"\n: {\n\"type\"\n:\n\"scalar\"\n,\n\"value\"\n:\n\"Functional\"\n}\n        }\n    },\n\"collection_relationships\"\n: {}\n}\n```\n\n### Binary Array-Valued Comparison Operators\n\nBinary comparison operators are denoted by expressions with a `type` field of `binary_array_comparison_operator` .\n\n#### in\n\n `in` tests if a column value is a member of an array of values, each of which can be a scalar value, another column value, or a variable.\n\nSee type[ ComparisonValue ](../../reference/types.html#comparisonvalue)for the valid inhabitants of the `value` field.\n\n *Note* : in general, `PathElement` s in a `ComparisonValue` can refer to *array* relationships. However, in the case of the `in` operator, such requests can be very difficult to implement, and for practical purposes, it is not very useful to express such queries. Therefore, in the case of the `in` operator, connectors can expect `PathElements` in `ComparisonValue` s to always only refer to *object* relationships, and fail with a `Bad Request` error otherwise.\n\n```\n{\n\"collection\"\n:\n\"articles\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n        },\n\"where\"\n: {\n\"type\"\n:\n\"binary_array_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"author_id\"\n,\n\"path\"\n: []\n            },\n\"operator\"\n:\n\"in\"\n,\n\"values\"\n: [\n                {\n\"type\"\n:\n\"scalar\"\n,\n\"value\"\n:\n1\n},\n                {\n\"type\"\n:\n\"scalar\"\n,\n\"value\"\n:\n2\n}\n            ]\n        }\n    },\n\"collection_relationships\"\n: {}\n}\n```\n\n### Columns in Operators\n\nComparison operators compare columns to values. The column on the left hand side of any operator is described by a[ ComparisonTarget ](../../reference/types.html#comparisontarget), and the various cases will be explained next.\n\n#### Referencing a column from the same collection\n\nIf the `ComparisonTarget` has type `column` , and the `path` property is empty, then the `name` property refers to a column in the current collection.\n\n#### Referencing a column from a related collection\n\nIf the `ComparisonTarget` has type `column` , and the `path` property is non-empty, then the `name` property refers to column in a related collection. The path consists of a collection of[ PathElement ](../../reference/types.html#pathelement)s, each of which references a named[ relationship ](./relationships.html), any[ collection arguments ](./arguments.html), and a[ predicate expression ](./filtering.html)to be applied to any relevant rows in the related collection.\n\nWhen a `PathElement` references an *array* relationship, the enclosing operator should be considered *existentially quantified* over all related rows.\n\n#### Referencing a column from the root collection\n\nIf the `ComparisonTarget` has type `root_collection_column` , then the `name` property refers to a column in the *root collection* .\n\nThe root collection is defined as the collection in scope at the nearest enclosing[ Query ](../../reference/types.html#query), and the column should be chosen from the *row* in that collection which was in scope when that `Query` was being evaluated.\n\n### Values in Binary Operators\n\nBinary (including array-valued) operators compare columns to *values* , but there are several types of valid values:\n\n- Scalar values, as seen in the examples above, compare the column to a specific value,\n- Variable values compare the column to the current value of a[ variable ](./variables.html),\n- Column values compare the column to *another* column, possibly selected from a different collection. Column values are also described by a[ ComparisonTarget ](../../reference/types.html#comparisontarget).\n\n\n## EXISTS expressions\n\nAn `EXISTS` expression tests whether a row exists in some possibly-related collection, and is denoted by an expression with a `type` field of `exists` .\n\n `EXISTS` expressions can query related or unrelated collections.\n\n### Related Collections\n\nRelated collections are related to the original collection by a relationship in the `collection_relationships` field of the top-level[ QueryRequest ](../../reference/types.html#queryrequest).\n\nFor example, this query fetches authors who have written articles whose titles contain the string `\"Functional\"` :\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n                    }\n                }\n            }\n        },\n\"where\"\n: {\n\"type\"\n:\n\"exists\"\n,\n\"in_collection\"\n: {\n\"type\"\n:\n\"related\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n},\n\"where\"\n: {\n\"type\"\n:\n\"binary_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"title\"\n,\n\"path\"\n: []\n                },\n\"operator\"\n: {\n\"type\"\n:\n\"other\"\n,\n\"name\"\n:\n\"like\"\n},\n\"value\"\n: {\n\"type\"\n:\n\"scalar\"\n,\n\"value\"\n:\n\"Functional\"\n}\n            }\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {\n\"id\"\n:\n\"author_id\"\n},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles\"\n}\n    }\n}\n```\n\n### Unrelated Collections\n\n```\n{\n\"collection\"\n:\n\"authors\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"first_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"first_name\"\n},\n\"last_name\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"last_name\"\n},\n\"articles\"\n: {\n\"type\"\n:\n\"relationship\"\n,\n\"arguments\"\n: {},\n\"relationship\"\n:\n\"author_articles\"\n,\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n                    }\n                }\n            }\n        },\n\"where\"\n: {\n\"type\"\n:\n\"exists\"\n,\n\"in_collection\"\n: {\n\"type\"\n:\n\"unrelated\"\n,\n\"arguments\"\n: {},\n\"collection\"\n:\n\"articles\"\n},\n\"where\"\n: {\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: [\n                    {\n\"type\"\n:\n\"binary_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"author_id\"\n,\n\"path\"\n: []\n                        },\n\"operator\"\n: {\n\"type\"\n:\n\"equal\"\n},\n\"value\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"root_collection_column\"\n,\n\"name\"\n:\n\"id\"\n}\n                        }\n                    },\n                    {\n\"type\"\n:\n\"binary_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"title\"\n,\n\"path\"\n: []\n                        },\n\"operator\"\n: {\n\"type\"\n:\n\"other\"\n,\n\"name\"\n:\n\"like\"\n},\n\"value\"\n: {\n\"type\"\n:\n\"scalar\"\n,\n\"value\"\n:\n\"Functional\"\n}\n                    }\n                ]\n            }\n        }\n    },\n\"collection_relationships\"\n: {\n\"author_articles\"\n: {\n\"arguments\"\n: {},\n\"column_mapping\"\n: {\n\"id\"\n:\n\"author_id\"\n},\n\"relationship_type\"\n:\n\"array\"\n,\n\"source_collection_or_type\"\n:\n\"author\"\n,\n\"target_collection\"\n:\n\"articles\"\n}\n    }\n}\n```\n\n## Conjunction of expressions\n\nTo express the conjunction of multiple expressions, specify a `type` field of `and` , and provide the expressions in the `expressions` field.\n\nFor example, to test if the `first_name` column is null *and* the `last_name` column is also null:\n\n```\n{\n\"type\"\n:\n\"and\"\n,\n\"expressions\"\n: [\n        {\n\"type\"\n:\n\"unary_comparison_operator\"\n,\n\"operator\"\n:\n\"is_null\"\n,\n\"column\"\n: {\n\"name\"\n:\n\"first_name\"\n}\n        },\n        {\n\"type\"\n:\n\"unary_comparison_operator\"\n,\n\"operator\"\n:\n\"is_null\"\n,\n\"column\"\n: {\n\"name\"\n:\n\"last_name\"\n}\n        }\n    ]\n}\n```\n\n## Disjunction of expressions\n\nTo express the disjunction of multiple expressions, specify a `type` field of `or` , and provide the expressions in the `expressions` field.\n\nFor example, to test if the `first_name` column is null *or* the `last_name` column is also null:\n\n```\n{\n\"type\"\n:\n\"or\"\n,\n\"expressions\"\n: [\n        {\n\"type\"\n:\n\"unary_comparison_operator\"\n,\n\"operator\"\n:\n\"is_null\"\n,\n\"column\"\n: {\n\"name\"\n:\n\"first_name\"\n}\n        },\n        {\n\"type\"\n:\n\"unary_comparison_operator\"\n,\n\"operator\"\n:\n\"is_null\"\n,\n\"column\"\n: {\n\"name\"\n:\n\"last_name\"\n}\n        }\n    ]\n}\n```\n\n## Negation\n\nTo express the negation of an expressions, specify a `type` field of `not` , and provide that expression in the `expression` field.\n\nFor example, to test if the `first_name` column is *not* null:\n\n```\n{\n\"type\"\n:\n\"not\"\n,\n\"expression\"\n: {\n\"type\"\n:\n\"unary_comparison_operator\"\n,\n\"operator\"\n:\n\"is_null\"\n,\n\"column\"\n: {\n\"name\"\n:\n\"first_name\"\n}\n    }\n}\n```\n\n## See also\n\n- Type[ Expression ](../../reference/types.html#expression)\n",
    "files/ndc-spec/specification/queries/variables.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Variables\n\nA[ QueryRequest ](../../reference/types.html#queryrequest)can optionally specify one or more sets of variables which can be referenced throughout the[ Query ](../../reference/types.html#query)object.\n\nQuery variables will only be provided if the `query.variables` [ capability ](../capabilities.html)is advertised in the capabilities response.\n\nThe intent is that the data connector should attempt to perform multiple versions of the query in parallel - one instance of the query for each set of variables. For each set of variables, each variable value should be substituted wherever it is referenced in the query - for example in a[ ComparisonValue ](../../reference/types.html#comparisonvalue).\n\n## Example\n\nIn the following query, we fetch two rowsets of article data. In each rowset, the rows are filtered based on the `author_id` column, and the prescribed `author_id` is determined by a variable. The choice of `author_id` varies between rowsets.\n\nThe result contains one rowset containing articles from the author with ID `1` , and a second for the author with ID `2` .\n\n```\n{\n\"collection\"\n:\n\"articles\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n        },\n\"where\"\n: {\n\"type\"\n:\n\"binary_comparison_operator\"\n,\n\"column\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"name\"\n:\n\"id\"\n,\n\"path\"\n: []\n            },\n\"operator\"\n: {\n\"type\"\n:\n\"equal\"\n},\n\"value\"\n: {\n\"type\"\n:\n\"variable\"\n,\n\"name\"\n:\n\"$article_id\"\n}\n        }\n    },\n\"collection_relationships\"\n: {},\n\"variables\"\n: [\n        {\n\"$article_id\"\n:\n1\n},\n        {\n\"$article_id\"\n:\n2\n}\n    ]\n}\n```\n\n## Requirements\n\n- If `variables` are provided in the[ QueryRequest ](../../reference/types.html#queryrequest), then the[ QueryResponse ](../../reference/types.html#queryresponse)should contain one[ RowSet ](../../reference/types.html#rowset)for each set of variables.\n- If `variables` are not provided, the data connector should return a single[ RowSet ](../../reference/types.html#rowset).\n",
    "files/ndc-spec/specification/queries/field-selection.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Field Selection\n\nA[ Query ](../../reference/types.html#query)can specify which fields to fetch. The available fields are either\n\n- the columns on the selected collection (i.e. those advertised in the corresponding[ CollectionInfo ](../../reference/types.html#collectioninfo)structure in the[ schema response ](../schema/collections.html)), or\n- fields from[ related collections ](./relationships.html)\n\n\nThe requested fields are specified as a collection of[ Field ](../../reference/types.html#field)structures in the `field` property on the[ Query ](../../reference/types.html#query).\n\n## Example\n\nHere is an example of a query which selects some columns from the `articles` collection of the reference data connector:\n\n```\n{\n\"collection\"\n:\n\"articles\"\n,\n\"arguments\"\n: {},\n\"query\"\n: {\n\"fields\"\n: {\n\"id\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"id\"\n},\n\"title\"\n: {\n\"type\"\n:\n\"column\"\n,\n\"column\"\n:\n\"title\"\n}\n        }\n    },\n\"collection_relationships\"\n: {}\n}\n```\n\n## Requirements\n\n- If the[ QueryRequest ](../../reference/types.html#queryrequest)contains a[ Query ](../../reference/types.html#query)which specifies `fields` , then each[ RowSet ](../../reference/types.html#rowset)in the response should contain the `rows` property, and each row should contain all of the requested fields.\n\n\n## See also\n\n- Type[ Query ](../../reference/types.html#query)\n- Type[ RowFieldValue ](../../reference/types.html#rowfieldvalue)\n- Type[ RowSet ](../../reference/types.html#rowset)\n",
    "files/ndc-spec/specification/schema/procedures.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Procedures\n\nThe schema should define metadata for each *procedure* which the data connector implements.\n\nEach procedure is defined by its name, any arguments types and a result type.\n\nTo describe a procedure, add a[ ProcedureInfo ](../../reference/types.html#procedureinfo)structure to the `procedure` field of the schema response.\n\n## Example\n\n```\n{\n\"procedures\"\n: [\n    {\n\"name\"\n:\n\"upsert_article\"\n,\n\"description\"\n:\n\"Insert or update an article\"\n,\n\"arguments\"\n: {\n\"article\"\n: {\n\"description\"\n:\n\"The article to insert or update\"\n,\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"article\"\n}\n        }\n      },\n\"result_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"article\"\n}\n    }\n  ],\n  ...\n}\n```\n\n## See also\n\n- Type[ ProcedureInfo ](../../reference/types.html#procedureinfo)\n",
    "files/ndc-spec/specification/schema/index.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Schema\n\nThe schema endpoint defines any types used by the data connector, and describes the collections and their columns, functions, and any procedures.\n\nThe schema endpoint is used to specify the behavior of a data connector, so that it can be tested, verified, and used by tools such as code generators. It is primarily provided by data connector implementors as a development and specification tool, and it is not expected to be used at \"runtime\", in the same sense that the `/query` and `/mutation` endpoints would be.\n\n## Request\n\n`GET /schema`\n\n## Response\n\nSee[ SchemaResponse ](../../reference/types.html#schemaresponse)\n\n### Example\n\n```\n{\n\"scalar_types\"\n: {\n\"Int\"\n: {\n\"aggregate_functions\"\n: {\n\"max\"\n: {\n\"result_type\"\n: {\n\"type\"\n:\n\"nullable\"\n,\n\"underlying_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Int\"\n}\n          }\n        },\n\"min\"\n: {\n\"result_type\"\n: {\n\"type\"\n:\n\"nullable\"\n,\n\"underlying_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Int\"\n}\n          }\n        }\n      },\n\"comparison_operators\"\n: {}\n    },\n\"String\"\n: {\n\"aggregate_functions\"\n: {},\n\"comparison_operators\"\n: {\n\"like\"\n: {\n\"argument_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"String\"\n}\n        }\n      }\n    }\n  },\n\"object_types\"\n: {\n\"article\"\n: {\n\"description\"\n:\n\"An article\"\n,\n\"fields\"\n: {\n\"author_id\"\n: {\n\"description\"\n:\n\"The article's author ID\"\n,\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Int\"\n}\n        },\n\"id\"\n: {\n\"description\"\n:\n\"The article's primary key\"\n,\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Int\"\n}\n        },\n\"title\"\n: {\n\"description\"\n:\n\"The article's title\"\n,\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"String\"\n}\n        }\n      }\n    },\n\"author\"\n: {\n\"description\"\n:\n\"An author\"\n,\n\"fields\"\n: {\n\"first_name\"\n: {\n\"description\"\n:\n\"The author's first name\"\n,\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"String\"\n}\n        },\n\"id\"\n: {\n\"description\"\n:\n\"The author's primary key\"\n,\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Int\"\n}\n        },\n\"last_name\"\n: {\n\"description\"\n:\n\"The author's last name\"\n,\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"String\"\n}\n        }\n      }\n    }\n  },\n\"collections\"\n: [\n    {\n\"name\"\n:\n\"articles\"\n,\n\"description\"\n:\n\"A collection of articles\"\n,\n\"arguments\"\n: {},\n\"type\"\n:\n\"article\"\n,\n\"uniqueness_constraints\"\n: {\n\"ArticleByID\"\n: {\n\"unique_columns\"\n: [\n\"id\"\n]\n        }\n      },\n\"foreign_keys\"\n: {\n\"Article_AuthorID\"\n: {\n\"column_mapping\"\n: {\n\"author_id\"\n:\n\"id\"\n},\n\"foreign_collection\"\n:\n\"authors\"\n}\n      }\n    },\n    {\n\"name\"\n:\n\"authors\"\n,\n\"description\"\n:\n\"A collection of authors\"\n,\n\"arguments\"\n: {},\n\"type\"\n:\n\"author\"\n,\n\"uniqueness_constraints\"\n: {\n\"AuthorByID\"\n: {\n\"unique_columns\"\n: [\n\"id\"\n]\n        }\n      },\n\"foreign_keys\"\n: {}\n    },\n    {\n\"name\"\n:\n\"articles_by_author\"\n,\n\"description\"\n:\n\"Articles parameterized by author\"\n,\n\"arguments\"\n: {\n\"author_id\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Int\"\n}\n        }\n      },\n\"type\"\n:\n\"article\"\n,\n\"uniqueness_constraints\"\n: {},\n\"foreign_keys\"\n: {}\n    }\n  ],\n\"functions\"\n: [\n    {\n\"name\"\n:\n\"latest_article_id\"\n,\n\"description\"\n:\n\"Get the ID of the most recent article\"\n,\n\"arguments\"\n: {},\n\"result_type\"\n: {\n\"type\"\n:\n\"nullable\"\n,\n\"underlying_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Int\"\n}\n      }\n    }\n  ],\n\"procedures\"\n: [\n    {\n\"name\"\n:\n\"upsert_article\"\n,\n\"description\"\n:\n\"Insert or update an article\"\n,\n\"arguments\"\n: {\n\"article\"\n: {\n\"description\"\n:\n\"The article to insert or update\"\n,\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"article\"\n}\n        }\n      },\n\"result_type\"\n: {\n\"type\"\n:\n\"nullable\"\n,\n\"underlying_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"article\"\n}\n      }\n    }\n  ]\n}\n```\n\n## Response Fields\n\n| Name | Description |\n|---|---|\n|  `scalar_types`  | [ Scalar Types ](scalar-types.html) |\n|  `object_types`  | [ Object Types ](object-types.html) |\n|  `collections`  | [ Collection ](collections.html) |\n|  `functions`  | [ Functions ](functions.html) |\n|  `procedures`  | [ Procedures ](procedures.html) |\n",
    "files/ndc-spec/specification/schema/scalar-types.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Scalar Types\n\nThe schema should describe any irreducible *scalar types* . Scalar types can be used as the types of columns, or in general as the types of object fields.\n\nScalar types define several types of operations, which extend the capabilities of the query and mutation APIs: *comparison operators* and *aggregation functions* .\n\n## Comparison Operators\n\nComparison operators extend the query AST with the ability to express new binary comparison expressions in the predicate.\n\n *Note* : data connectors are required to implement the *equality* operator for all scalar types, and that operator is distinguished in the query AST. There is no need to define the equality operator as a comparison operator.\n\nFor example, a data connector might augment a `String` scalar type with a `LIKE` operator which tests for a fuzzy match based on a regular expression.\n\nA comparison operator is defined by its *argument type* - that is, the type of the right hand side of the binary operator it represents.\n\nTo define a comparison operator, add a[ ComparisonOperatorDefinition ](../../reference/types.html#comparisonoperatordefinition)to the `comparison_operators` field of the schema response.\n\nFor example:\n\n```\n{\n\"scalar_types\"\n: {\n\"String\"\n: {\n\"aggregate_functions\"\n: {},\n\"comparison_operators\"\n: {\n\"like\"\n: {\n\"argument_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"String\"\n}\n        }\n      }\n    }\n  },\n  ...\n}\n```\n\n## Aggregation Functions\n\nAggregation functions extend the query AST with the ability to express new aggregates within the `aggregates` portion of a query. They also allow sorting the query results via the `order_by` query field.\n\n *Note* : data connectors are required to implement the *count* and *count-distinct* aggregations for columns of all scalar types, and those operator is distinguished in the query AST. There is no need to define these aggregates as aggregation functions.\n\nFor example, a data connector might augment a `Float` scalar type with a `SUM` function which aggregates a sum of a collection of floating-point numbers.\n\nAn aggregation function is defined by its *result type* - that is, the type of the aggregated data.\n\nTo define an aggregation function, add a[ AggregateFunctionDefinition ](../../reference/types.html#aggregatefunctiondefinition)to the `aggregate_functions` field of the schema response.\n\nFor example:\n\n```\n{\n\"scalar_types\"\n: {\n\"Float\"\n: {\n\"aggregate_functions\"\n: {\n\"sum\"\n: {\n\"result_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Float\"\n}\n        }\n      },\n\"comparison_operators\"\n: {}\n    }\n  },\n  ...\n}\n```\n\n## See also\n\n- Type[ ScalarType ](../../reference/types.html#scalartype)\n- [ Filtering ](../queries/filtering.html)\n- [ Sorting ](../queries/sorting.html)\n- [ Aggregates ](../queries/aggregates.html)\n",
    "files/ndc-spec/specification/schema/collections.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Collections\n\nThe schema should define the metadata for any *collections* which can be queried using the query endpoint, or mutated using the mutation endpoint.\n\nEach collection is defined by its name, any collection[ arguments ](../queries/arguments.html), the[ object type ](./object-types.html)of its rows, and some additional metadata related to permissions and constraints.\n\nTo describe a collection, add a[ CollectionInfo ](../../reference/types.html#collectioninfo)structure to the `collections` field of the schema response.\n\n## Requirements\n\n- The `type` field should name an object type which is defined in the schema response.\n\n\n## Example\n\n```\n{\n\"collections\"\n: [\n    {\n\"name\"\n:\n\"articles\"\n,\n\"description\"\n:\n\"A collection of articles\"\n,\n\"arguments\"\n: {},\n\"type\"\n:\n\"article\"\n,\n\"deletable\"\n:\nfalse\n,\n\"uniqueness_constraints\"\n: {\n\"ArticleByID\"\n: {\n\"unique_columns\"\n: [\n\"id\"\n]\n        }\n      },\n\"foreign_keys\"\n: {}\n    },\n    {\n\"name\"\n:\n\"authors\"\n,\n\"description\"\n:\n\"A collection of authors\"\n,\n\"arguments\"\n: {},\n\"type\"\n:\n\"author\"\n,\n\"deletable\"\n:\nfalse\n,\n\"uniqueness_constraints\"\n: {\n\"AuthorByID\"\n: {\n\"unique_columns\"\n: [\n\"id\"\n]\n        }\n      },\n\"foreign_keys\"\n: {}\n    }\n  ],\n  ...\n}\n```\n\n## See also\n\n- Type[ CollectionInfo ](../../reference/types.html#collectioninfo)\n",
    "files/ndc-spec/specification/schema/functions.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Functions\n\nFunctions are a special case of[ collections ](./collections.html), which are identified separately in the schema for convenience.\n\nA function is a collection which returns a single row and a single column, named `__value` . Like collections, functions can have arguments. Unlike collections, functions cannot be used by the mutations endpoint, do not describe constraints, and only provide a type for the `__value` column, not the name of an object type.\n\n *Note* : even though a function acts like a collection returning a row type with a single column, there is no need to define and name such a type in the `object_types` section of the schema response.\n\nTo describe a function, add a[ FunctionInfo ](../../reference/types.html#FunctionInfo)structure to the `functions` field of the schema response.\n\n## Example\n\n```\n{\n\"functions\"\n: [\n    {\n\"name\"\n:\n\"latest_article_id\"\n,\n\"description\"\n:\n\"Get the ID of the most recent article\"\n,\n\"arguments\"\n: {},\n\"result_type\"\n: {\n\"type\"\n:\n\"nullable\"\n,\n\"underlying_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Int\"\n}\n      }\n    }\n  ],\n  ...\n}\n```\n\n## See also\n\n- Type[ FunctionInfo ](../../reference/types.html#FunctionInfo)\n",
    "files/ndc-spec/specification/schema/object-types.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Object Types\n\nThe schema should define any named *object types* which will be used as the types of[ collection ](./collections.html)row sets, or[ procedure ](./procedures.html)inputs or outputs.\n\nAn object type consists of a name and a collection of named fields. Each field is defined by its[ type ](../types.html), and any[ arguments ](../queries/arguments.html).\n\n *Note* : field arguments are only used in a query context, and ignored when an object type is used in other contexts (such as the input type of a *procedure* ).\n\nTo define an object type, add an[ ObjectType\n ](../../reference/types.html#objecttype)to the `object_types` field of the schema response.\n\n## Example\n\n```\n{\n\"object_types\"\n: {\n\"coords\"\n: {\n\"description\"\n:\n\"Latitude and longitude\"\n,\n\"fields\"\n: {\n\"latitude\"\n: {\n\"description\"\n:\n\"Latitude in degrees north of the equator\"\n,\n\"arguments\"\n: {},\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Float\"\n}\n        },\n\"longitude\"\n: {\n\"description\"\n:\n\"Longitude in degrees east of the Greenwich meridian\"\n,\n\"arguments\"\n: {},\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Float\"\n}\n        }\n      }\n    },\n    ...\n  },\n  ...\n}\n```\n\n## Extended Example\n\nObject types can refer to other object types in the types of their fields, and make use of other[ type structure ](../types.html)such as array types and nullable types.\n\nIn the context of array types, it can be useful to use[ arguments ](../queries/arguments.html)on fields to allow the caller to customize the response.\n\nFor example, here we define a type `widget` , and a second type which contains a `widgets` field, parameterized by a `limit` argument:\n\n```\n{\n\"object_types\"\n: {\n\"widget\"\n: {\n\"description\"\n:\n\"Description of a widget\"\n,\n\"fields\"\n: {\n\"id\"\n: {\n\"description\"\n:\n\"Primary key\"\n,\n\"arguments\"\n: {},\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"ID\"\n}\n        },\n\"name\"\n: {\n\"description\"\n:\n\"Name of this widget\"\n,\n\"arguments\"\n: {},\n\"type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"String\"\n}\n        }\n      }\n    },\n\"inventory\"\n: {\n\"description\"\n:\n\"The items in stock\"\n,\n\"fields\"\n: {\n\"widgets\"\n: {\n\"description\"\n:\n\"Those widgets currently in stock\"\n,\n\"arguments\"\n: {\n\"limit\"\n: {\n\"description\"\n:\n\"The maximum number of widgets to fetch\"\n,\n\"argument_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"Int\"\n}\n            }\n          },\n\"type\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"element_type\"\n: {\n\"type\"\n:\n\"named\"\n,\n\"name\"\n:\n\"widget\"\n}\n          }\n        }\n      }\n    }\n  },\n  ...\n}\n```\n\n## See also\n\n- Type[ ObjectType ](../../reference/types.html#objecttype)\n- Type[ ObjectField ](../../reference/types.html#objectfield)\n",
    "files/ndc-spec/reference/types.html.md": "# Hasura Data Connectors Developer's Guide\n\n# Types\n\n## Aggregate\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\n#[schemars(title =  \"Aggregate\" )]\npub\nenum   Aggregate\n{\n    ColumnCount {\n/// The column to apply the count aggregate function to\ncolumn:\nString\n,\n/// Whether or not only distinct items should be counted\ndistinct:\nbool\n,\n    },\n    SingleColumn {\n/// The column to apply the aggregation function to\ncolumn:\nString\n,\n/// Single column aggregate function name.\nfunction:\nString\n,\n    },\n    StarCount {},\n}\n```\n\n## AggregateFunctionDefinition\n\n```\n/// The definition of an aggregation function on a scalar type\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Aggregate Function Definition\" )]\npub\nstruct   AggregateFunctionDefinition\n{\n/// The scalar or object type of the result of this function\npub\nresult_type: Type,\n}\n```\n\n## Argument\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\n#[schemars(title =  \"Argument\" )]\npub\nenum   Argument\n{\n/// The argument is provided by reference to a variable\nVariable { name:\nString\n},\n/// The argument is provided as a literal value\nLiteral { value: serde_json::Value },\n}\n```\n\n## ArgumentInfo\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Argument Info\" )]\npub\nstruct   ArgumentInfo\n{\n/// Argument description\npub\ndescription:\nOption\n<\nString\n>,\n/// The name of the type of this argument\n#[serde(rename =  \"type\" )]\npub\nargument_type: Type,\n}\n```\n\n## BinaryArrayComparisonOperator\n\n```\n#[derive(\n    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,\n)]\n#[schemars(title =  \"Binary Array Comparison Operator\" )]\n#[serde(rename_all =  \"snake_case\" )]\npub\nenum   BinaryArrayComparisonOperator\n{\n    In,\n}\n```\n\n## BinaryComparisonOperator\n\n```\n#[derive(\n    Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,\n)]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\n#[schemars(title =  \"Binary Comparison Operator\" )]\npub\nenum   BinaryComparisonOperator\n{\n    Equal,\n// should we rename this? To what?\nOther { name:\nString\n},\n}\n```\n\n## Capabilities\n\n```\n/// Describes the features of the specification which a data connector implements.\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Capabilities\" )]\npub\nstruct   Capabilities\n{\npub\nquery: QueryCapabilities,\npub\nexplain:\nOption\n<LeafCapability>,\npub\nrelationships:\nOption\n<RelationshipCapabilities>,\n}\n```\n\n## CapabilitiesResponse\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Capabilities Response\" )]\npub\nstruct   CapabilitiesResponse\n{\npub\nversions:\nString\n,\npub\ncapabilities: Capabilities,\n}\n```\n\n## ComparisonOperatorDefinition\n\n```\n/// The definition of a comparison operator on a scalar type\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Comparison Operator Definition\" )]\npub\nstruct   ComparisonOperatorDefinition\n{\n/// The type of the argument to this operator\npub\nargument_type: Type,\n}\n```\n\n## ComparisonTarget\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Comparison Target\" )]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\npub\nenum   ComparisonTarget\n{\n    Column {\n/// The name of the column\nname:\nString\n,\n/// Any relationships to traverse to reach this column\npath:\nVec\n<PathElement>,\n    },\n    RootCollectionColumn {\n/// The name of the column\nname:\nString\n,\n    },\n}\n```\n\n## ComparisonValue\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\n#[schemars(title =  \"Comparison Value\" )]\npub\nenum   ComparisonValue\n{\n    Column { column: ComparisonTarget },\n    Scalar { value: serde_json::Value },\n    Variable { name:\nString\n},\n}\n```\n\n## ErrorResponse\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Error Response\" )]\npub\nstruct   ErrorResponse\n{\n/// A human-readable summary of the error\npub\nmessage:\nString\n,\n/// Any additional structured information about the error\npub\ndetails: serde_json::Value,\n}\n```\n\n## ExistsInCollection\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\n#[schemars(title =  \"Exists In Collection\" )]\npub\nenum   ExistsInCollection\n{\n    Related {\n        relationship:\nString\n,\n/// Values to be provided to any collection arguments\narguments: BTreeMap<\nString\n, RelationshipArgument>,\n    },\n    Unrelated {\n/// The name of a collection\ncollection:\nString\n,\n/// Values to be provided to any collection arguments\narguments: BTreeMap<\nString\n, RelationshipArgument>,\n    },\n}\n```\n\n## ExplainResponse\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Explain Response\" )]\npub\nstruct   ExplainResponse\n{\n/// A list of human-readable key-value pairs describing\n/// a query execution plan. For example, a connector for\n/// a relational database might return the generated SQL\n/// and/or the output of the `EXPLAIN` command. An API-based\n/// connector might encode a list of statically-known API\n/// calls which would be made.\npub\ndetails: BTreeMap<\nString\n,\nString\n>,\n}\n```\n\n## Expression\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\n#[schemars(title =  \"Expression\" )]\npub\nenum   Expression\n{\n    And {\n        expressions:\nVec\n<Expression>,\n    },\n    Or {\n        expressions:\nVec\n<Expression>,\n    },\n    Not {\n        expression:\nBox\n<Expression>,\n    },\n    UnaryComparisonOperator {\n        column: ComparisonTarget,\n        operator: UnaryComparisonOperator,\n    },\n    BinaryComparisonOperator {\n        column: ComparisonTarget,\n        operator: BinaryComparisonOperator,\n        value: ComparisonValue,\n    },\n    BinaryArrayComparisonOperator {\n        column: ComparisonTarget,\n        operator: BinaryArrayComparisonOperator,\n        values:\nVec\n<ComparisonValue>,\n    },\n    Exists {\n        in_collection: ExistsInCollection,\n#[serde(rename =  \"where\" )]\npredicate:\nBox\n<Expression>,\n    },\n}\n```\n\n## Field\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\n#[schemars(title =  \"Field\" )]\npub\nenum   Field\n{\n    Column {\n        column:\nString\n,\n    },\n    Relationship {\n        query:\nBox\n<Query>,\n/// The name of the relationship to follow for the subquery\nrelationship:\nString\n,\n/// Values to be provided to any collection arguments\narguments: BTreeMap<\nString\n, RelationshipArgument>,\n    },\n}\n```\n\n## ForeignKeyConstraint\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Foreign Key Constraint\" )]\npub\nstruct   ForeignKeyConstraint\n{\n/// The columns on which you want want to define the foreign key.\npub\ncolumn_mapping: BTreeMap<\nString\n,\nString\n>,\n/// The name of a collection\npub\nforeign_collection:\nString\n,\n}\n```\n\n## FunctionInfo\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Function Info\" )]\npub\nstruct   FunctionInfo\n{\n/// The name of the function\npub\nname:\nString\n,\n/// Description of the function\npub\ndescription:\nOption\n<\nString\n>,\n/// Any arguments that this collection requires\npub\narguments: BTreeMap<\nString\n, ArgumentInfo>,\n/// The name of the function's result type\npub\nresult_type: Type,\n}\n```\n\n## LeafCapability\n\n```\n/// A unit value to indicate a particular leaf capability is supported.\n/// This is an empty struct to allow for future sub-capabilities.\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\npub\nstruct   LeafCapability\n{}\n```\n\n## MutationOperation\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Mutation Operation\" )]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\npub\nenum   MutationOperation\n{\n    Procedure {\n/// The name of a procedure\nname:\nString\n,\n/// Any named procedure arguments\narguments: BTreeMap<\nString\n, serde_json::Value>,\n/// The fields to return\nfields:\nOption\n<IndexMap<\nString\n, Field>>,\n    },\n}\n```\n\n## MutationOperationResults\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Mutation Operation Results\" )]\npub\nstruct   MutationOperationResults\n{\n/// The number of rows affected by the mutation operation\npub\naffected_rows:\nu32\n,\n/// The rows affected by the mutation operation\npub\nreturning:\nOption\n<\nVec\n<IndexMap<\nString\n, RowFieldValue>>>,\n}\n```\n\n## MutationRequest\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Mutation Request\" )]\npub\nstruct   MutationRequest\n{\n/// The mutation operations to perform\npub\noperations:\nVec\n<MutationOperation>,\n/// The relationships between collections involved in the entire mutation request\npub\ncollection_relationships: BTreeMap<\nString\n, Relationship>,\n}\n```\n\n## MutationResponse\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Mutation Response\" )]\npub\nstruct   MutationResponse\n{\n/// The results of each mutation operation, in the same order as they were received\npub\noperation_results:\nVec\n<MutationOperationResults>,\n}\n```\n\n## ObjectField\n\n```\n/// The definition of an object field\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Object Field\" )]\npub\nstruct   ObjectField\n{\n/// Description of this field\npub\ndescription:\nOption\n<\nString\n>,\n/// The type of this field\n#[serde(rename =  \"type\" )]\npub\nr#\ntype :  Type\n,\n}\n```\n\n## ObjectType\n\n```\n/// The definition of an object type\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Object Type\" )]\npub\nstruct   ObjectType\n{\n/// Description of this type\npub\ndescription:\nOption\n<\nString\n>,\n/// Fields defined on this object type\npub\nfields: BTreeMap<\nString\n, ObjectField>,\n}\n```\n\n## OrderBy\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Order By\" )]\npub\nstruct   OrderBy\n{\n/// The elements to order by, in priority order\npub\nelements:\nVec\n<OrderByElement>,\n}\n```\n\n## OrderByElement\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Order By Element\" )]\npub\nstruct   OrderByElement\n{\npub\norder_direction: OrderDirection,\npub\ntarget: OrderByTarget,\n}\n```\n\n## OrderByTarget\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Order By Target\" )]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\npub\nenum   OrderByTarget\n{\n    Column {\n/// The name of the column\nname:\nString\n,\n/// Any relationships to traverse to reach this column\npath:\nVec\n<PathElement>,\n    },\n    SingleColumnAggregate {\n/// The column to apply the aggregation function to\ncolumn:\nString\n,\n/// Single column aggregate function name.\nfunction:\nString\n,\n/// Non-empty collection of relationships to traverse\npath:\nVec\n<PathElement>,\n    },\n    StarCountAggregate {\n/// Non-empty collection of relationships to traverse\npath:\nVec\n<PathElement>,\n    },\n}\n```\n\n## OrderDirection\n\n```\n#[derive(\n    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,\n)]\n#[schemars(title =  \"Order Direction\" )]\n#[serde(rename_all =  \"snake_case\" )]\npub\nenum   OrderDirection\n{\n    Asc,\n    Desc,\n}\n```\n\n## PathElement\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[serde(rename_all =  \"snake_case\" )]\n#[schemars(title =  \"Path Element\" )]\npub\nstruct   PathElement\n{\n/// The name of the relationship to follow\npub\nrelationship:\nString\n,\n/// Values to be provided to any collection arguments\npub\narguments: BTreeMap<\nString\n, RelationshipArgument>,\n/// A predicate expression to apply to the target collection\npub\npredicate:\nBox\n<Expression>,\n}\n```\n\n## ProcedureInfo\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Procedure Info\" )]\npub\nstruct   ProcedureInfo\n{\n/// The name of the procedure\npub\nname:\nString\n,\n/// Column description\npub\ndescription:\nOption\n<\nString\n>,\n/// Any arguments that this collection requires\npub\narguments: BTreeMap<\nString\n, ArgumentInfo>,\n/// The name of the result type\npub\nresult_type: Type,\n}\n```\n\n## Query\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Query\" )]\npub\nstruct   Query\n{\n/// Aggregate fields of the query\npub\naggregates:\nOption\n<IndexMap<\nString\n, Aggregate>>,\n/// Fields of the query\npub\nfields:\nOption\n<IndexMap<\nString\n, Field>>,\n/// Optionally limit to N results\npub\nlimit:\nOption\n<\nu32\n>,\n/// Optionally offset from the Nth result\npub\noffset:\nOption\n<\nu32\n>,\npub\norder_by:\nOption\n<OrderBy>,\n#[serde(rename =  \"where\" )]\npub\npredicate:\nOption\n<Expression>,\n}\n```\n\n## QueryCapabilities\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Query Capabilities\" )]\npub\nstruct   QueryCapabilities\n{\n/// Does the connector support aggregate queries\npub\naggregates:\nOption\n<LeafCapability>,\n/// Does the connector support queries which use variables\npub\nvariables:\nOption\n<LeafCapability>,\n}\n```\n\n## QueryRequest\n\n```\n/// This is the request body of the query POST endpoint\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Query Request\" )]\npub\nstruct   QueryRequest\n{\n/// The name of a collection\npub\ncollection:\nString\n,\n/// The query syntax tree\npub\nquery: Query,\n/// Values to be provided to any collection arguments\npub\narguments: BTreeMap<\nString\n, Argument>,\n/// Any relationships between collections involved in the query request\npub\ncollection_relationships: BTreeMap<\nString\n, Relationship>,\n/// One set of named variables for each rowset to fetch. Each variable set\n/// should be subtituted in turn, and a fresh set of rows returned.\npub\nvariables:\nOption\n<\nVec\n<BTreeMap<\nString\n, serde_json::Value>>>,\n}\n```\n\n## QueryResponse\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Query Response\" )]\n/// Query responses may return multiple RowSets when using queries with variables.\n/// Else, there should always be exactly one RowSet\npub\nstruct   QueryResponse\n(\npub\nVec\n<RowSet>);\n```\n\n## Relationship\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Relationship\" )]\npub\nstruct   Relationship\n{\n/// A mapping between columns on the source collection to columns on the target collection\npub\ncolumn_mapping: BTreeMap<\nString\n,\nString\n>,\npub\nrelationship_type: RelationshipType,\n/// The name of a collection\npub\ntarget_collection:\nString\n,\n/// Values to be provided to any collection arguments\npub\narguments: BTreeMap<\nString\n, RelationshipArgument>,\n}\n```\n\n## RelationshipArgument\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Relationship Argument\" )]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\npub\nenum   RelationshipArgument\n{\n/// The argument is provided by reference to a variable\nVariable {\n        name:\nString\n,\n    },\n/// The argument is provided as a literal value\nLiteral {\n        value: serde_json::Value,\n    },\n// The argument is provided based on a column of the source collection\nColumn {\n        name:\nString\n,\n    },\n}\n```\n\n## RelationshipCapabilities\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Relationship Capabilities\" )]\npub\nstruct   RelationshipCapabilities\n{\n/// Does the connector support comparisons that involve related collections (ie. joins)?\npub\nrelation_comparisons:\nOption\n<LeafCapability>,\n/// Does the connector support ordering by an aggregated array relationship?\npub\norder_by_aggregate:\nOption\n<LeafCapability>,\n}\n```\n\n## RelationshipType\n\n```\n#[derive(\n    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,\n)]\n#[schemars(title =  \"Relationship Type\" )]\n#[serde(rename_all =  \"snake_case\" )]\npub\nenum   RelationshipType\n{\n    Object,\n    Array,\n}\n```\n\n## RowFieldValue\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Row Field Value\" )]\npub\nstruct   RowFieldValue\n(\npub\nserde_json::Value);\nimpl\nRowFieldValue {\n/// In the case where this field value was obtained using a\n/// [`Field::Relationship`], the returned JSON will be a [`RowSet`].\n/// We cannot express [`RowFieldValue`] as an enum, because\n/// [`RowFieldValue`] overlaps with values which have object types.\npub\nfn   as_rowset\n(\nself\n) ->\nOption\n<RowSet> {\n        serde_json::from_value(\nself\n.\n0\n).ok()\n    }\n}\n```\n\n## RowSet\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Row Set\" )]\npub\nstruct   RowSet\n{\n/// The results of the aggregates returned by the query\npub\naggregates:\nOption\n<IndexMap<\nString\n, serde_json::Value>>,\n/// The rows returned by the query, corresponding to the query's fields\npub\nrows:\nOption\n<\nVec\n<IndexMap<\nString\n, RowFieldValue>>>,\n}\n```\n\n## ScalarType\n\n```\n/// The definition of a scalar type, i.e. types that can be used as the types of columns.\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Scalar Type\" )]\npub\nstruct   ScalarType\n{\n/// A map from aggregate function names to their definitions. Result type names must be defined scalar types declared in ScalarTypesCapabilities.\npub\naggregate_functions: BTreeMap<\nString\n, AggregateFunctionDefinition>,\n/// A map from comparison operator names to their definitions. Argument type names must be defined scalar types declared in ScalarTypesCapabilities.\npub\ncomparison_operators: BTreeMap<\nString\n, ComparisonOperatorDefinition>,\n}\n```\n\n## SchemaResponse\n\n```\n#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Schema Response\" )]\npub\nstruct   SchemaResponse\n{\n/// A list of scalar types which will be used as the types of collection columns\npub\nscalar_types: BTreeMap<\nString\n, ScalarType>,\n/// A list of object types which can be used as the types of arguments, or return types of procedures.\n/// Names should not overlap with scalar type names.\npub\nobject_types: BTreeMap<\nString\n, ObjectType>,\n/// Collections which are available for queries\npub\ncollections:\nVec\n<CollectionInfo>,\n/// Functions (i.e. collections which return a single column and row)\npub\nfunctions:\nVec\n<FunctionInfo>,\n/// Procedures which are available for execution as part of mutations\npub\nprocedures:\nVec\n<ProcedureInfo>,\n}\n```\n\n## CollectionInfo\n\n```\n#[skip_serializing_none]\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Collection Info\" )]\npub\nstruct   CollectionInfo\n{\n/// The name of the collection\n///\n/// Note: these names are abstract - there is no requirement that this name correspond to\n/// the name of an actual collection in the database.\npub\nname:\nString\n,\n/// Description of the collection\npub\ndescription:\nOption\n<\nString\n>,\n/// Any arguments that this collection requires\npub\narguments: BTreeMap<\nString\n, ArgumentInfo>,\n/// The name of the collection's object type\n#[serde(rename =  \"type\" )]\npub\ncollection_type:\nString\n,\n/// Any uniqueness constraints enforced on this collection\npub\nuniqueness_constraints: BTreeMap<\nString\n, UniquenessConstraint>,\n/// Any foreign key constraints enforced on this collection\npub\nforeign_keys: BTreeMap<\nString\n, ForeignKeyConstraint>,\n}\n```\n\n## Type\n\n```\n/// Types track the valid representations of values as JSON\n#[derive(\n    Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,\n)]\n#[serde(tag =  \"type\" , rename_all =  \"snake_case\" )]\n#[schemars(title =  \"Type\" )]\npub\nenum   Type\n{\n/// A named type\nNamed {\n/// The name can refer to a primitive type or a scalar type\nname:\nString\n,\n    },\n/// A nullable type\nNullable {\n/// The type of the non-null inhabitants of this type\nunderlying_type:\nBox\n<Type>,\n    },\n/// An array type\nArray {\n/// The type of the elements of the array\nelement_type:\nBox\n<Type>,\n    },\n}\n```\n\n## UnaryComparisonOperator\n\n```\n#[derive(\n    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,\n)]\n#[schemars(title =  \"Unary Comparison Operator\" )]\n#[serde(rename_all =  \"snake_case\" )]\npub\nenum   UnaryComparisonOperator\n{\n    IsNull,\n}\n```\n\n## UniquenessConstraint\n\n```\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]\n#[schemars(title =  \"Uniqueness Constraint\" )]\npub\nstruct   UniquenessConstraint\n{\n/// A list of columns which this constraint requires to be unique\npub\nunique_columns:\nVec\n<\nString\n>,\n}\n```",
    "files/ndc-spec/reference/json-schema.html.md": "# Hasura Data Connectors Developer's Guide\n\n# JSON Schema\n\n## CapabilitiesResponse\n\n```\n{\n\"$schema\"\n:\n\"http://json-schema.org/draft-07/schema#\"\n,\n\"title\"\n:\n\"Capabilities Response\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"capabilities\"\n,\n\"versions\"\n],\n\"properties\"\n: {\n\"versions\"\n: {\n\"type\"\n:\n\"string\"\n},\n\"capabilities\"\n: {\n\"$ref\"\n:\n\"#/definitions/Capabilities\"\n}\n  },\n\"definitions\"\n: {\n\"Capabilities\"\n: {\n\"title\"\n:\n\"Capabilities\"\n,\n\"description\"\n:\n\"Describes the features of the specification which a data connector implements.\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"query\"\n],\n\"properties\"\n: {\n\"query\"\n: {\n\"$ref\"\n:\n\"#/definitions/QueryCapabilities\"\n},\n\"explain\"\n: {\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/LeafCapability\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        },\n\"relationships\"\n: {\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/RelationshipCapabilities\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        }\n      }\n    },\n\"QueryCapabilities\"\n: {\n\"title\"\n:\n\"Query Capabilities\"\n,\n\"type\"\n:\n\"object\"\n,\n\"properties\"\n: {\n\"aggregates\"\n: {\n\"description\"\n:\n\"Does the connector support aggregate queries\"\n,\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/LeafCapability\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        },\n\"variables\"\n: {\n\"description\"\n:\n\"Does the connector support queries which use variables\"\n,\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/LeafCapability\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        }\n      }\n    },\n\"LeafCapability\"\n: {\n\"description\"\n:\n\"A unit value to indicate a particular leaf capability is supported. This is an empty struct to allow for future sub-capabilities.\"\n,\n\"type\"\n:\n\"object\"\n},\n\"RelationshipCapabilities\"\n: {\n\"title\"\n:\n\"Relationship Capabilities\"\n,\n\"type\"\n:\n\"object\"\n,\n\"properties\"\n: {\n\"relation_comparisons\"\n: {\n\"description\"\n:\n\"Does the connector support comparisons that involve related collections (ie. joins)?\"\n,\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/LeafCapability\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        },\n\"order_by_aggregate\"\n: {\n\"description\"\n:\n\"Does the connector support ordering by an aggregated array relationship?\"\n,\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/LeafCapability\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        }\n      }\n    }\n  }\n}\n```\n\n## ErrorResponse\n\n```\n{\n\"$schema\"\n:\n\"http://json-schema.org/draft-07/schema#\"\n,\n\"title\"\n:\n\"Error Response\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"details\"\n,\n\"message\"\n],\n\"properties\"\n: {\n\"message\"\n: {\n\"description\"\n:\n\"A human-readable summary of the error\"\n,\n\"type\"\n:\n\"string\"\n},\n\"details\"\n: {\n\"description\"\n:\n\"Any additional structured information about the error\"\n}\n  }\n}\n```\n\n## ExplainResponse\n\n```\n{\n\"$schema\"\n:\n\"http://json-schema.org/draft-07/schema#\"\n,\n\"title\"\n:\n\"Explain Response\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"details\"\n],\n\"properties\"\n: {\n\"details\"\n: {\n\"description\"\n:\n\"A list of human-readable key-value pairs describing a query execution plan. For example, a connector for a relational database might return the generated SQL and/or the output of the `EXPLAIN` command. An API-based connector might encode a list of statically-known API calls which would be made.\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"type\"\n:\n\"string\"\n}\n    }\n  }\n}\n```\n\n## MutationRequest\n\n```\n{\n\"$schema\"\n:\n\"http://json-schema.org/draft-07/schema#\"\n,\n\"title\"\n:\n\"Mutation Request\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"collection_relationships\"\n,\n\"operations\"\n],\n\"properties\"\n: {\n\"operations\"\n: {\n\"description\"\n:\n\"The mutation operations to perform\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/MutationOperation\"\n}\n    },\n\"collection_relationships\"\n: {\n\"description\"\n:\n\"The relationships between collections involved in the entire mutation request\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Relationship\"\n}\n    }\n  },\n\"definitions\"\n: {\n\"MutationOperation\"\n: {\n\"title\"\n:\n\"Mutation Operation\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"procedure\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name of a procedure\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Any named procedure arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n:\ntrue\n},\n\"fields\"\n: {\n\"description\"\n:\n\"The fields to return\"\n,\n\"type\"\n: [\n\"object\"\n,\n\"null\"\n],\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Field\"\n}\n            }\n          }\n        }\n      ]\n    },\n\"Field\"\n: {\n\"title\"\n:\n\"Field\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"column\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"query\"\n,\n\"relationship\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"relationship\"\n]\n            },\n\"query\"\n: {\n\"$ref\"\n:\n\"#/definitions/Query\"\n},\n\"relationship\"\n: {\n\"description\"\n:\n\"The name of the relationship to follow for the subquery\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n            }\n          }\n        }\n      ]\n    },\n\"Query\"\n: {\n\"title\"\n:\n\"Query\"\n,\n\"type\"\n:\n\"object\"\n,\n\"properties\"\n: {\n\"aggregates\"\n: {\n\"description\"\n:\n\"Aggregate fields of the query\"\n,\n\"type\"\n: [\n\"object\"\n,\n\"null\"\n],\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Aggregate\"\n}\n        },\n\"fields\"\n: {\n\"description\"\n:\n\"Fields of the query\"\n,\n\"type\"\n: [\n\"object\"\n,\n\"null\"\n],\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Field\"\n}\n        },\n\"limit\"\n: {\n\"description\"\n:\n\"Optionally limit to N results\"\n,\n\"type\"\n: [\n\"integer\"\n,\n\"null\"\n],\n\"format\"\n:\n\"uint32\"\n,\n\"minimum\"\n:\n0.0\n},\n\"offset\"\n: {\n\"description\"\n:\n\"Optionally offset from the Nth result\"\n,\n\"type\"\n: [\n\"integer\"\n,\n\"null\"\n],\n\"format\"\n:\n\"uint32\"\n,\n\"minimum\"\n:\n0.0\n},\n\"order_by\"\n: {\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/OrderBy\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        },\n\"where\"\n: {\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        }\n      }\n    },\n\"Aggregate\"\n: {\n\"title\"\n:\n\"Aggregate\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"distinct\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column_count\"\n]\n            },\n\"column\"\n: {\n\"description\"\n:\n\"The column to apply the count aggregate function to\"\n,\n\"type\"\n:\n\"string\"\n},\n\"distinct\"\n: {\n\"description\"\n:\n\"Whether or not only distinct items should be counted\"\n,\n\"type\"\n:\n\"boolean\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"function\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"single_column\"\n]\n            },\n\"column\"\n: {\n\"description\"\n:\n\"The column to apply the aggregation function to\"\n,\n\"type\"\n:\n\"string\"\n},\n\"function\"\n: {\n\"description\"\n:\n\"Single column aggregate function name.\"\n,\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"star_count\"\n]\n            }\n          }\n        }\n      ]\n    },\n\"OrderBy\"\n: {\n\"title\"\n:\n\"Order By\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"elements\"\n],\n\"properties\"\n: {\n\"elements\"\n: {\n\"description\"\n:\n\"The elements to order by, in priority order\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/OrderByElement\"\n}\n        }\n      }\n    },\n\"OrderByElement\"\n: {\n\"title\"\n:\n\"Order By Element\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"order_direction\"\n,\n\"target\"\n],\n\"properties\"\n: {\n\"order_direction\"\n: {\n\"$ref\"\n:\n\"#/definitions/OrderDirection\"\n},\n\"target\"\n: {\n\"$ref\"\n:\n\"#/definitions/OrderByTarget\"\n}\n      }\n    },\n\"OrderDirection\"\n: {\n\"title\"\n:\n\"Order Direction\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"asc\"\n,\n\"desc\"\n]\n    },\n\"OrderByTarget\"\n: {\n\"title\"\n:\n\"Order By Target\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name of the column\"\n,\n\"type\"\n:\n\"string\"\n},\n\"path\"\n: {\n\"description\"\n:\n\"Any relationships to traverse to reach this column\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"function\"\n,\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"single_column_aggregate\"\n]\n            },\n\"column\"\n: {\n\"description\"\n:\n\"The column to apply the aggregation function to\"\n,\n\"type\"\n:\n\"string\"\n},\n\"function\"\n: {\n\"description\"\n:\n\"Single column aggregate function name.\"\n,\n\"type\"\n:\n\"string\"\n},\n\"path\"\n: {\n\"description\"\n:\n\"Non-empty collection of relationships to traverse\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"star_count_aggregate\"\n]\n            },\n\"path\"\n: {\n\"description\"\n:\n\"Non-empty collection of relationships to traverse\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        }\n      ]\n    },\n\"PathElement\"\n: {\n\"title\"\n:\n\"Path Element\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"predicate\"\n,\n\"relationship\"\n],\n\"properties\"\n: {\n\"relationship\"\n: {\n\"description\"\n:\n\"The name of the relationship to follow\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n        },\n\"predicate\"\n: {\n\"description\"\n:\n\"A predicate expression to apply to the target collection\"\n,\n\"allOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n          ]\n        }\n      }\n    },\n\"RelationshipArgument\"\n: {\n\"title\"\n:\n\"Relationship Argument\"\n,\n\"oneOf\"\n: [\n        {\n\"description\"\n:\n\"The argument is provided by reference to a variable\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"variable\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"description\"\n:\n\"The argument is provided as a literal value\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"literal\"\n]\n            },\n\"value\"\n:\ntrue\n}\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"Expression\"\n: {\n\"title\"\n:\n\"Expression\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"expressions\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"and\"\n]\n            },\n\"expressions\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"expressions\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"or\"\n]\n            },\n\"expressions\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"expression\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"not\"\n]\n            },\n\"expression\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"operator\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"unary_comparison_operator\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n},\n\"operator\"\n: {\n\"$ref\"\n:\n\"#/definitions/UnaryComparisonOperator\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"operator\"\n,\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"binary_comparison_operator\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n},\n\"operator\"\n: {\n\"$ref\"\n:\n\"#/definitions/BinaryComparisonOperator\"\n},\n\"value\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonValue\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"operator\"\n,\n\"type\"\n,\n\"values\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"binary_array_comparison_operator\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n},\n\"operator\"\n: {\n\"$ref\"\n:\n\"#/definitions/BinaryArrayComparisonOperator\"\n},\n\"values\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonValue\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"in_collection\"\n,\n\"type\"\n,\n\"where\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"exists\"\n]\n            },\n\"in_collection\"\n: {\n\"$ref\"\n:\n\"#/definitions/ExistsInCollection\"\n},\n\"where\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n          }\n        }\n      ]\n    },\n\"ComparisonTarget\"\n: {\n\"title\"\n:\n\"Comparison Target\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name of the column\"\n,\n\"type\"\n:\n\"string\"\n},\n\"path\"\n: {\n\"description\"\n:\n\"Any relationships to traverse to reach this column\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"root_collection_column\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name of the column\"\n,\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"UnaryComparisonOperator\"\n: {\n\"title\"\n:\n\"Unary Comparison Operator\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"is_null\"\n]\n    },\n\"BinaryComparisonOperator\"\n: {\n\"title\"\n:\n\"Binary Comparison Operator\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"equal\"\n]\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"other\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"ComparisonValue\"\n: {\n\"title\"\n:\n\"Comparison Value\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"scalar\"\n]\n            },\n\"value\"\n:\ntrue\n}\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"variable\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"BinaryArrayComparisonOperator\"\n: {\n\"title\"\n:\n\"Binary Array Comparison Operator\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"in\"\n]\n    },\n\"ExistsInCollection\"\n: {\n\"title\"\n:\n\"Exists In Collection\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"relationship\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"related\"\n]\n            },\n\"relationship\"\n: {\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"collection\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"unrelated\"\n]\n            },\n\"collection\"\n: {\n\"description\"\n:\n\"The name of a collection\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n            }\n          }\n        }\n      ]\n    },\n\"Relationship\"\n: {\n\"title\"\n:\n\"Relationship\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"column_mapping\"\n,\n\"relationship_type\"\n,\n\"target_collection\"\n],\n\"properties\"\n: {\n\"column_mapping\"\n: {\n\"description\"\n:\n\"A mapping between columns on the source collection to columns on the target collection\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"type\"\n:\n\"string\"\n}\n        },\n\"relationship_type\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipType\"\n},\n\"target_collection\"\n: {\n\"description\"\n:\n\"The name of a collection\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n        }\n      }\n    },\n\"RelationshipType\"\n: {\n\"title\"\n:\n\"Relationship Type\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"object\"\n,\n\"array\"\n]\n    }\n  }\n}\n```\n\n## MutationResponse\n\n```\n{\n\"$schema\"\n:\n\"http://json-schema.org/draft-07/schema#\"\n,\n\"title\"\n:\n\"Mutation Response\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"operation_results\"\n],\n\"properties\"\n: {\n\"operation_results\"\n: {\n\"description\"\n:\n\"The results of each mutation operation, in the same order as they were received\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/MutationOperationResults\"\n}\n    }\n  },\n\"definitions\"\n: {\n\"MutationOperationResults\"\n: {\n\"title\"\n:\n\"Mutation Operation Results\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"affected_rows\"\n],\n\"properties\"\n: {\n\"affected_rows\"\n: {\n\"description\"\n:\n\"The number of rows affected by the mutation operation\"\n,\n\"type\"\n:\n\"integer\"\n,\n\"format\"\n:\n\"uint32\"\n,\n\"minimum\"\n:\n0.0\n},\n\"returning\"\n: {\n\"description\"\n:\n\"The rows affected by the mutation operation\"\n,\n\"type\"\n: [\n\"array\"\n,\n\"null\"\n],\n\"items\"\n: {\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RowFieldValue\"\n}\n          }\n        }\n      }\n    },\n\"RowFieldValue\"\n: {\n\"title\"\n:\n\"Row Field Value\"\n}\n  }\n}\n```\n\n## QueryRequest\n\n```\n{\n\"$schema\"\n:\n\"http://json-schema.org/draft-07/schema#\"\n,\n\"title\"\n:\n\"Query Request\"\n,\n\"description\"\n:\n\"This is the request body of the query POST endpoint\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"collection\"\n,\n\"collection_relationships\"\n,\n\"query\"\n],\n\"properties\"\n: {\n\"collection\"\n: {\n\"description\"\n:\n\"The name of a collection\"\n,\n\"type\"\n:\n\"string\"\n},\n\"query\"\n: {\n\"description\"\n:\n\"The query syntax tree\"\n,\n\"allOf\"\n: [\n        {\n\"$ref\"\n:\n\"#/definitions/Query\"\n}\n      ]\n    },\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Argument\"\n}\n    },\n\"collection_relationships\"\n: {\n\"description\"\n:\n\"Any relationships between collections involved in the query request\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Relationship\"\n}\n    },\n\"variables\"\n: {\n\"description\"\n:\n\"One set of named variables for each rowset to fetch. Each variable set should be subtituted in turn, and a fresh set of rows returned.\"\n,\n\"type\"\n: [\n\"array\"\n,\n\"null\"\n],\n\"items\"\n: {\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n:\ntrue\n}\n    }\n  },\n\"definitions\"\n: {\n\"Query\"\n: {\n\"title\"\n:\n\"Query\"\n,\n\"type\"\n:\n\"object\"\n,\n\"properties\"\n: {\n\"aggregates\"\n: {\n\"description\"\n:\n\"Aggregate fields of the query\"\n,\n\"type\"\n: [\n\"object\"\n,\n\"null\"\n],\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Aggregate\"\n}\n        },\n\"fields\"\n: {\n\"description\"\n:\n\"Fields of the query\"\n,\n\"type\"\n: [\n\"object\"\n,\n\"null\"\n],\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Field\"\n}\n        },\n\"limit\"\n: {\n\"description\"\n:\n\"Optionally limit to N results\"\n,\n\"type\"\n: [\n\"integer\"\n,\n\"null\"\n],\n\"format\"\n:\n\"uint32\"\n,\n\"minimum\"\n:\n0.0\n},\n\"offset\"\n: {\n\"description\"\n:\n\"Optionally offset from the Nth result\"\n,\n\"type\"\n: [\n\"integer\"\n,\n\"null\"\n],\n\"format\"\n:\n\"uint32\"\n,\n\"minimum\"\n:\n0.0\n},\n\"order_by\"\n: {\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/OrderBy\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        },\n\"where\"\n: {\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        }\n      }\n    },\n\"Aggregate\"\n: {\n\"title\"\n:\n\"Aggregate\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"distinct\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column_count\"\n]\n            },\n\"column\"\n: {\n\"description\"\n:\n\"The column to apply the count aggregate function to\"\n,\n\"type\"\n:\n\"string\"\n},\n\"distinct\"\n: {\n\"description\"\n:\n\"Whether or not only distinct items should be counted\"\n,\n\"type\"\n:\n\"boolean\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"function\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"single_column\"\n]\n            },\n\"column\"\n: {\n\"description\"\n:\n\"The column to apply the aggregation function to\"\n,\n\"type\"\n:\n\"string\"\n},\n\"function\"\n: {\n\"description\"\n:\n\"Single column aggregate function name.\"\n,\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"star_count\"\n]\n            }\n          }\n        }\n      ]\n    },\n\"Field\"\n: {\n\"title\"\n:\n\"Field\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"column\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"query\"\n,\n\"relationship\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"relationship\"\n]\n            },\n\"query\"\n: {\n\"$ref\"\n:\n\"#/definitions/Query\"\n},\n\"relationship\"\n: {\n\"description\"\n:\n\"The name of the relationship to follow for the subquery\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n            }\n          }\n        }\n      ]\n    },\n\"RelationshipArgument\"\n: {\n\"title\"\n:\n\"Relationship Argument\"\n,\n\"oneOf\"\n: [\n        {\n\"description\"\n:\n\"The argument is provided by reference to a variable\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"variable\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"description\"\n:\n\"The argument is provided as a literal value\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"literal\"\n]\n            },\n\"value\"\n:\ntrue\n}\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"OrderBy\"\n: {\n\"title\"\n:\n\"Order By\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"elements\"\n],\n\"properties\"\n: {\n\"elements\"\n: {\n\"description\"\n:\n\"The elements to order by, in priority order\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/OrderByElement\"\n}\n        }\n      }\n    },\n\"OrderByElement\"\n: {\n\"title\"\n:\n\"Order By Element\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"order_direction\"\n,\n\"target\"\n],\n\"properties\"\n: {\n\"order_direction\"\n: {\n\"$ref\"\n:\n\"#/definitions/OrderDirection\"\n},\n\"target\"\n: {\n\"$ref\"\n:\n\"#/definitions/OrderByTarget\"\n}\n      }\n    },\n\"OrderDirection\"\n: {\n\"title\"\n:\n\"Order Direction\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"asc\"\n,\n\"desc\"\n]\n    },\n\"OrderByTarget\"\n: {\n\"title\"\n:\n\"Order By Target\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name of the column\"\n,\n\"type\"\n:\n\"string\"\n},\n\"path\"\n: {\n\"description\"\n:\n\"Any relationships to traverse to reach this column\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"function\"\n,\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"single_column_aggregate\"\n]\n            },\n\"column\"\n: {\n\"description\"\n:\n\"The column to apply the aggregation function to\"\n,\n\"type\"\n:\n\"string\"\n},\n\"function\"\n: {\n\"description\"\n:\n\"Single column aggregate function name.\"\n,\n\"type\"\n:\n\"string\"\n},\n\"path\"\n: {\n\"description\"\n:\n\"Non-empty collection of relationships to traverse\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"star_count_aggregate\"\n]\n            },\n\"path\"\n: {\n\"description\"\n:\n\"Non-empty collection of relationships to traverse\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        }\n      ]\n    },\n\"PathElement\"\n: {\n\"title\"\n:\n\"Path Element\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"predicate\"\n,\n\"relationship\"\n],\n\"properties\"\n: {\n\"relationship\"\n: {\n\"description\"\n:\n\"The name of the relationship to follow\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n        },\n\"predicate\"\n: {\n\"description\"\n:\n\"A predicate expression to apply to the target collection\"\n,\n\"allOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n          ]\n        }\n      }\n    },\n\"Expression\"\n: {\n\"title\"\n:\n\"Expression\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"expressions\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"and\"\n]\n            },\n\"expressions\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"expressions\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"or\"\n]\n            },\n\"expressions\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"expression\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"not\"\n]\n            },\n\"expression\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"operator\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"unary_comparison_operator\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n},\n\"operator\"\n: {\n\"$ref\"\n:\n\"#/definitions/UnaryComparisonOperator\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"operator\"\n,\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"binary_comparison_operator\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n},\n\"operator\"\n: {\n\"$ref\"\n:\n\"#/definitions/BinaryComparisonOperator\"\n},\n\"value\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonValue\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"operator\"\n,\n\"type\"\n,\n\"values\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"binary_array_comparison_operator\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n},\n\"operator\"\n: {\n\"$ref\"\n:\n\"#/definitions/BinaryArrayComparisonOperator\"\n},\n\"values\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonValue\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"in_collection\"\n,\n\"type\"\n,\n\"where\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"exists\"\n]\n            },\n\"in_collection\"\n: {\n\"$ref\"\n:\n\"#/definitions/ExistsInCollection\"\n},\n\"where\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n          }\n        }\n      ]\n    },\n\"ComparisonTarget\"\n: {\n\"title\"\n:\n\"Comparison Target\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name of the column\"\n,\n\"type\"\n:\n\"string\"\n},\n\"path\"\n: {\n\"description\"\n:\n\"Any relationships to traverse to reach this column\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"root_collection_column\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name of the column\"\n,\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"UnaryComparisonOperator\"\n: {\n\"title\"\n:\n\"Unary Comparison Operator\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"is_null\"\n]\n    },\n\"BinaryComparisonOperator\"\n: {\n\"title\"\n:\n\"Binary Comparison Operator\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"equal\"\n]\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"other\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"ComparisonValue\"\n: {\n\"title\"\n:\n\"Comparison Value\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"scalar\"\n]\n            },\n\"value\"\n:\ntrue\n}\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"variable\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"BinaryArrayComparisonOperator\"\n: {\n\"title\"\n:\n\"Binary Array Comparison Operator\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"in\"\n]\n    },\n\"ExistsInCollection\"\n: {\n\"title\"\n:\n\"Exists In Collection\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"relationship\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"related\"\n]\n            },\n\"relationship\"\n: {\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"collection\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"unrelated\"\n]\n            },\n\"collection\"\n: {\n\"description\"\n:\n\"The name of a collection\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n            }\n          }\n        }\n      ]\n    },\n\"Argument\"\n: {\n\"title\"\n:\n\"Argument\"\n,\n\"oneOf\"\n: [\n        {\n\"description\"\n:\n\"The argument is provided by reference to a variable\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"variable\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"description\"\n:\n\"The argument is provided as a literal value\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"literal\"\n]\n            },\n\"value\"\n:\ntrue\n}\n        }\n      ]\n    },\n\"Relationship\"\n: {\n\"title\"\n:\n\"Relationship\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"column_mapping\"\n,\n\"relationship_type\"\n,\n\"target_collection\"\n],\n\"properties\"\n: {\n\"column_mapping\"\n: {\n\"description\"\n:\n\"A mapping between columns on the source collection to columns on the target collection\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"type\"\n:\n\"string\"\n}\n        },\n\"relationship_type\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipType\"\n},\n\"target_collection\"\n: {\n\"description\"\n:\n\"The name of a collection\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n        }\n      }\n    },\n\"RelationshipType\"\n: {\n\"title\"\n:\n\"Relationship Type\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"object\"\n,\n\"array\"\n]\n    }\n  }\n}\n```\n\n## QueryResponse\n\n```\n{\n\"$schema\"\n:\n\"http://json-schema.org/draft-07/schema#\"\n,\n\"title\"\n:\n\"Query Response\"\n,\n\"description\"\n:\n\"Query responses may return multiple RowSets when using queries with variables. Else, there should always be exactly one RowSet\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/RowSet\"\n},\n\"definitions\"\n: {\n\"RowSet\"\n: {\n\"title\"\n:\n\"Row Set\"\n,\n\"type\"\n:\n\"object\"\n,\n\"properties\"\n: {\n\"aggregates\"\n: {\n\"description\"\n:\n\"The results of the aggregates returned by the query\"\n,\n\"type\"\n: [\n\"object\"\n,\n\"null\"\n],\n\"additionalProperties\"\n:\ntrue\n},\n\"rows\"\n: {\n\"description\"\n:\n\"The rows returned by the query, corresponding to the query's fields\"\n,\n\"type\"\n: [\n\"array\"\n,\n\"null\"\n],\n\"items\"\n: {\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RowFieldValue\"\n}\n          }\n        }\n      }\n    },\n\"RowFieldValue\"\n: {\n\"title\"\n:\n\"Row Field Value\"\n}\n  }\n}\n```\n\n## QueryRequest\n\n```\n{\n\"$schema\"\n:\n\"http://json-schema.org/draft-07/schema#\"\n,\n\"title\"\n:\n\"Query Request\"\n,\n\"description\"\n:\n\"This is the request body of the query POST endpoint\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"collection\"\n,\n\"collection_relationships\"\n,\n\"query\"\n],\n\"properties\"\n: {\n\"collection\"\n: {\n\"description\"\n:\n\"The name of a collection\"\n,\n\"type\"\n:\n\"string\"\n},\n\"query\"\n: {\n\"description\"\n:\n\"The query syntax tree\"\n,\n\"allOf\"\n: [\n        {\n\"$ref\"\n:\n\"#/definitions/Query\"\n}\n      ]\n    },\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Argument\"\n}\n    },\n\"collection_relationships\"\n: {\n\"description\"\n:\n\"Any relationships between collections involved in the query request\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Relationship\"\n}\n    },\n\"variables\"\n: {\n\"description\"\n:\n\"One set of named variables for each rowset to fetch. Each variable set should be subtituted in turn, and a fresh set of rows returned.\"\n,\n\"type\"\n: [\n\"array\"\n,\n\"null\"\n],\n\"items\"\n: {\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n:\ntrue\n}\n    }\n  },\n\"definitions\"\n: {\n\"Query\"\n: {\n\"title\"\n:\n\"Query\"\n,\n\"type\"\n:\n\"object\"\n,\n\"properties\"\n: {\n\"aggregates\"\n: {\n\"description\"\n:\n\"Aggregate fields of the query\"\n,\n\"type\"\n: [\n\"object\"\n,\n\"null\"\n],\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Aggregate\"\n}\n        },\n\"fields\"\n: {\n\"description\"\n:\n\"Fields of the query\"\n,\n\"type\"\n: [\n\"object\"\n,\n\"null\"\n],\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/Field\"\n}\n        },\n\"limit\"\n: {\n\"description\"\n:\n\"Optionally limit to N results\"\n,\n\"type\"\n: [\n\"integer\"\n,\n\"null\"\n],\n\"format\"\n:\n\"uint32\"\n,\n\"minimum\"\n:\n0.0\n},\n\"offset\"\n: {\n\"description\"\n:\n\"Optionally offset from the Nth result\"\n,\n\"type\"\n: [\n\"integer\"\n,\n\"null\"\n],\n\"format\"\n:\n\"uint32\"\n,\n\"minimum\"\n:\n0.0\n},\n\"order_by\"\n: {\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/OrderBy\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        },\n\"where\"\n: {\n\"anyOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n},\n            {\n\"type\"\n:\n\"null\"\n}\n          ]\n        }\n      }\n    },\n\"Aggregate\"\n: {\n\"title\"\n:\n\"Aggregate\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"distinct\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column_count\"\n]\n            },\n\"column\"\n: {\n\"description\"\n:\n\"The column to apply the count aggregate function to\"\n,\n\"type\"\n:\n\"string\"\n},\n\"distinct\"\n: {\n\"description\"\n:\n\"Whether or not only distinct items should be counted\"\n,\n\"type\"\n:\n\"boolean\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"function\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"single_column\"\n]\n            },\n\"column\"\n: {\n\"description\"\n:\n\"The column to apply the aggregation function to\"\n,\n\"type\"\n:\n\"string\"\n},\n\"function\"\n: {\n\"description\"\n:\n\"Single column aggregate function name.\"\n,\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"star_count\"\n]\n            }\n          }\n        }\n      ]\n    },\n\"Field\"\n: {\n\"title\"\n:\n\"Field\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"column\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"query\"\n,\n\"relationship\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"relationship\"\n]\n            },\n\"query\"\n: {\n\"$ref\"\n:\n\"#/definitions/Query\"\n},\n\"relationship\"\n: {\n\"description\"\n:\n\"The name of the relationship to follow for the subquery\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n            }\n          }\n        }\n      ]\n    },\n\"RelationshipArgument\"\n: {\n\"title\"\n:\n\"Relationship Argument\"\n,\n\"oneOf\"\n: [\n        {\n\"description\"\n:\n\"The argument is provided by reference to a variable\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"variable\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"description\"\n:\n\"The argument is provided as a literal value\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"literal\"\n]\n            },\n\"value\"\n:\ntrue\n}\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"OrderBy\"\n: {\n\"title\"\n:\n\"Order By\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"elements\"\n],\n\"properties\"\n: {\n\"elements\"\n: {\n\"description\"\n:\n\"The elements to order by, in priority order\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/OrderByElement\"\n}\n        }\n      }\n    },\n\"OrderByElement\"\n: {\n\"title\"\n:\n\"Order By Element\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"order_direction\"\n,\n\"target\"\n],\n\"properties\"\n: {\n\"order_direction\"\n: {\n\"$ref\"\n:\n\"#/definitions/OrderDirection\"\n},\n\"target\"\n: {\n\"$ref\"\n:\n\"#/definitions/OrderByTarget\"\n}\n      }\n    },\n\"OrderDirection\"\n: {\n\"title\"\n:\n\"Order Direction\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"asc\"\n,\n\"desc\"\n]\n    },\n\"OrderByTarget\"\n: {\n\"title\"\n:\n\"Order By Target\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name of the column\"\n,\n\"type\"\n:\n\"string\"\n},\n\"path\"\n: {\n\"description\"\n:\n\"Any relationships to traverse to reach this column\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"function\"\n,\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"single_column_aggregate\"\n]\n            },\n\"column\"\n: {\n\"description\"\n:\n\"The column to apply the aggregation function to\"\n,\n\"type\"\n:\n\"string\"\n},\n\"function\"\n: {\n\"description\"\n:\n\"Single column aggregate function name.\"\n,\n\"type\"\n:\n\"string\"\n},\n\"path\"\n: {\n\"description\"\n:\n\"Non-empty collection of relationships to traverse\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"star_count_aggregate\"\n]\n            },\n\"path\"\n: {\n\"description\"\n:\n\"Non-empty collection of relationships to traverse\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        }\n      ]\n    },\n\"PathElement\"\n: {\n\"title\"\n:\n\"Path Element\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"predicate\"\n,\n\"relationship\"\n],\n\"properties\"\n: {\n\"relationship\"\n: {\n\"description\"\n:\n\"The name of the relationship to follow\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n        },\n\"predicate\"\n: {\n\"description\"\n:\n\"A predicate expression to apply to the target collection\"\n,\n\"allOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n          ]\n        }\n      }\n    },\n\"Expression\"\n: {\n\"title\"\n:\n\"Expression\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"expressions\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"and\"\n]\n            },\n\"expressions\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"expressions\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"or\"\n]\n            },\n\"expressions\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"expression\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"not\"\n]\n            },\n\"expression\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"operator\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"unary_comparison_operator\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n},\n\"operator\"\n: {\n\"$ref\"\n:\n\"#/definitions/UnaryComparisonOperator\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"operator\"\n,\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"binary_comparison_operator\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n},\n\"operator\"\n: {\n\"$ref\"\n:\n\"#/definitions/BinaryComparisonOperator\"\n},\n\"value\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonValue\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"operator\"\n,\n\"type\"\n,\n\"values\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"binary_array_comparison_operator\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n},\n\"operator\"\n: {\n\"$ref\"\n:\n\"#/definitions/BinaryArrayComparisonOperator\"\n},\n\"values\"\n: {\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonValue\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"in_collection\"\n,\n\"type\"\n,\n\"where\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"exists\"\n]\n            },\n\"in_collection\"\n: {\n\"$ref\"\n:\n\"#/definitions/ExistsInCollection\"\n},\n\"where\"\n: {\n\"$ref\"\n:\n\"#/definitions/Expression\"\n}\n          }\n        }\n      ]\n    },\n\"ComparisonTarget\"\n: {\n\"title\"\n:\n\"Comparison Target\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"path\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name of the column\"\n,\n\"type\"\n:\n\"string\"\n},\n\"path\"\n: {\n\"description\"\n:\n\"Any relationships to traverse to reach this column\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/PathElement\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"root_collection_column\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name of the column\"\n,\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"UnaryComparisonOperator\"\n: {\n\"title\"\n:\n\"Unary Comparison Operator\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"is_null\"\n]\n    },\n\"BinaryComparisonOperator\"\n: {\n\"title\"\n:\n\"Binary Comparison Operator\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"equal\"\n]\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"other\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"ComparisonValue\"\n: {\n\"title\"\n:\n\"Comparison Value\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"column\"\n]\n            },\n\"column\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonTarget\"\n}\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"scalar\"\n]\n            },\n\"value\"\n:\ntrue\n}\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"variable\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        }\n      ]\n    },\n\"BinaryArrayComparisonOperator\"\n: {\n\"title\"\n:\n\"Binary Array Comparison Operator\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"in\"\n]\n    },\n\"ExistsInCollection\"\n: {\n\"title\"\n:\n\"Exists In Collection\"\n,\n\"oneOf\"\n: [\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"relationship\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"related\"\n]\n            },\n\"relationship\"\n: {\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n            }\n          }\n        },\n        {\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"collection\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"unrelated\"\n]\n            },\n\"collection\"\n: {\n\"description\"\n:\n\"The name of a collection\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n            }\n          }\n        }\n      ]\n    },\n\"Argument\"\n: {\n\"title\"\n:\n\"Argument\"\n,\n\"oneOf\"\n: [\n        {\n\"description\"\n:\n\"The argument is provided by reference to a variable\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"variable\"\n]\n            },\n\"name\"\n: {\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"description\"\n:\n\"The argument is provided as a literal value\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n,\n\"value\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"literal\"\n]\n            },\n\"value\"\n:\ntrue\n}\n        }\n      ]\n    },\n\"Relationship\"\n: {\n\"title\"\n:\n\"Relationship\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"column_mapping\"\n,\n\"relationship_type\"\n,\n\"target_collection\"\n],\n\"properties\"\n: {\n\"column_mapping\"\n: {\n\"description\"\n:\n\"A mapping between columns on the source collection to columns on the target collection\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"type\"\n:\n\"string\"\n}\n        },\n\"relationship_type\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipType\"\n},\n\"target_collection\"\n: {\n\"description\"\n:\n\"The name of a collection\"\n,\n\"type\"\n:\n\"string\"\n},\n\"arguments\"\n: {\n\"description\"\n:\n\"Values to be provided to any collection arguments\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/RelationshipArgument\"\n}\n        }\n      }\n    },\n\"RelationshipType\"\n: {\n\"title\"\n:\n\"Relationship Type\"\n,\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"object\"\n,\n\"array\"\n]\n    }\n  }\n}\n```\n\n## SchemaResponse\n\n```\n{\n\"$schema\"\n:\n\"http://json-schema.org/draft-07/schema#\"\n,\n\"title\"\n:\n\"Schema Response\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"collections\"\n,\n\"functions\"\n,\n\"object_types\"\n,\n\"procedures\"\n,\n\"scalar_types\"\n],\n\"properties\"\n: {\n\"scalar_types\"\n: {\n\"description\"\n:\n\"A list of scalar types which will be used as the types of collection columns\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/ScalarType\"\n}\n    },\n\"object_types\"\n: {\n\"description\"\n:\n\"A list of object types which can be used as the types of arguments, or return types of procedures. Names should not overlap with scalar type names.\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/ObjectType\"\n}\n    },\n\"collections\"\n: {\n\"description\"\n:\n\"Collections which are available for queries\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/CollectionInfo\"\n}\n    },\n\"functions\"\n: {\n\"description\"\n:\n\"Functions (i.e. collections which return a single column and row)\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/FunctionInfo\"\n}\n    },\n\"procedures\"\n: {\n\"description\"\n:\n\"Procedures which are available for execution as part of mutations\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"$ref\"\n:\n\"#/definitions/ProcedureInfo\"\n}\n    }\n  },\n\"definitions\"\n: {\n\"ScalarType\"\n: {\n\"title\"\n:\n\"Scalar Type\"\n,\n\"description\"\n:\n\"The definition of a scalar type, i.e. types that can be used as the types of columns.\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"aggregate_functions\"\n,\n\"comparison_operators\"\n],\n\"properties\"\n: {\n\"aggregate_functions\"\n: {\n\"description\"\n:\n\"A map from aggregate function names to their definitions. Result type names must be defined scalar types declared in ScalarTypesCapabilities.\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/AggregateFunctionDefinition\"\n}\n        },\n\"comparison_operators\"\n: {\n\"description\"\n:\n\"A map from comparison operator names to their definitions. Argument type names must be defined scalar types declared in ScalarTypesCapabilities.\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/ComparisonOperatorDefinition\"\n}\n        }\n      }\n    },\n\"AggregateFunctionDefinition\"\n: {\n\"title\"\n:\n\"Aggregate Function Definition\"\n,\n\"description\"\n:\n\"The definition of an aggregation function on a scalar type\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"result_type\"\n],\n\"properties\"\n: {\n\"result_type\"\n: {\n\"description\"\n:\n\"The scalar or object type of the result of this function\"\n,\n\"allOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Type\"\n}\n          ]\n        }\n      }\n    },\n\"Type\"\n: {\n\"title\"\n:\n\"Type\"\n,\n\"description\"\n:\n\"Types track the valid representations of values as JSON\"\n,\n\"oneOf\"\n: [\n        {\n\"description\"\n:\n\"A named type\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"name\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"named\"\n]\n            },\n\"name\"\n: {\n\"description\"\n:\n\"The name can refer to a primitive type or a scalar type\"\n,\n\"type\"\n:\n\"string\"\n}\n          }\n        },\n        {\n\"description\"\n:\n\"A nullable type\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n,\n\"underlying_type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"nullable\"\n]\n            },\n\"underlying_type\"\n: {\n\"description\"\n:\n\"The type of the non-null inhabitants of this type\"\n,\n\"allOf\"\n: [\n                {\n\"$ref\"\n:\n\"#/definitions/Type\"\n}\n              ]\n            }\n          }\n        },\n        {\n\"description\"\n:\n\"An array type\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"element_type\"\n,\n\"type\"\n],\n\"properties\"\n: {\n\"type\"\n: {\n\"type\"\n:\n\"string\"\n,\n\"enum\"\n: [\n\"array\"\n]\n            },\n\"element_type\"\n: {\n\"description\"\n:\n\"The type of the elements of the array\"\n,\n\"allOf\"\n: [\n                {\n\"$ref\"\n:\n\"#/definitions/Type\"\n}\n              ]\n            }\n          }\n        }\n      ]\n    },\n\"ComparisonOperatorDefinition\"\n: {\n\"title\"\n:\n\"Comparison Operator Definition\"\n,\n\"description\"\n:\n\"The definition of a comparison operator on a scalar type\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"argument_type\"\n],\n\"properties\"\n: {\n\"argument_type\"\n: {\n\"description\"\n:\n\"The type of the argument to this operator\"\n,\n\"allOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Type\"\n}\n          ]\n        }\n      }\n    },\n\"ObjectType\"\n: {\n\"title\"\n:\n\"Object Type\"\n,\n\"description\"\n:\n\"The definition of an object type\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"fields\"\n],\n\"properties\"\n: {\n\"description\"\n: {\n\"description\"\n:\n\"Description of this type\"\n,\n\"type\"\n: [\n\"string\"\n,\n\"null\"\n]\n        },\n\"fields\"\n: {\n\"description\"\n:\n\"Fields defined on this object type\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/ObjectField\"\n}\n        }\n      }\n    },\n\"ObjectField\"\n: {\n\"title\"\n:\n\"Object Field\"\n,\n\"description\"\n:\n\"The definition of an object field\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n],\n\"properties\"\n: {\n\"description\"\n: {\n\"description\"\n:\n\"Description of this field\"\n,\n\"type\"\n: [\n\"string\"\n,\n\"null\"\n]\n        },\n\"type\"\n: {\n\"description\"\n:\n\"The type of this field\"\n,\n\"allOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Type\"\n}\n          ]\n        }\n      }\n    },\n\"CollectionInfo\"\n: {\n\"title\"\n:\n\"Collection Info\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"foreign_keys\"\n,\n\"name\"\n,\n\"type\"\n,\n\"uniqueness_constraints\"\n],\n\"properties\"\n: {\n\"name\"\n: {\n\"description\"\n:\n\"The name of the collection\\n\\nNote: these names are abstract - there is no requirement that this name correspond to the name of an actual collection in the database.\"\n,\n\"type\"\n:\n\"string\"\n},\n\"description\"\n: {\n\"description\"\n:\n\"Description of the collection\"\n,\n\"type\"\n: [\n\"string\"\n,\n\"null\"\n]\n        },\n\"arguments\"\n: {\n\"description\"\n:\n\"Any arguments that this collection requires\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/ArgumentInfo\"\n}\n        },\n\"type\"\n: {\n\"description\"\n:\n\"The name of the collection's object type\"\n,\n\"type\"\n:\n\"string\"\n},\n\"uniqueness_constraints\"\n: {\n\"description\"\n:\n\"Any uniqueness constraints enforced on this collection\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/UniquenessConstraint\"\n}\n        },\n\"foreign_keys\"\n: {\n\"description\"\n:\n\"Any foreign key constraints enforced on this collection\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/ForeignKeyConstraint\"\n}\n        }\n      }\n    },\n\"ArgumentInfo\"\n: {\n\"title\"\n:\n\"Argument Info\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"type\"\n],\n\"properties\"\n: {\n\"description\"\n: {\n\"description\"\n:\n\"Argument description\"\n,\n\"type\"\n: [\n\"string\"\n,\n\"null\"\n]\n        },\n\"type\"\n: {\n\"description\"\n:\n\"The name of the type of this argument\"\n,\n\"allOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Type\"\n}\n          ]\n        }\n      }\n    },\n\"UniquenessConstraint\"\n: {\n\"title\"\n:\n\"Uniqueness Constraint\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"unique_columns\"\n],\n\"properties\"\n: {\n\"unique_columns\"\n: {\n\"description\"\n:\n\"A list of columns which this constraint requires to be unique\"\n,\n\"type\"\n:\n\"array\"\n,\n\"items\"\n: {\n\"type\"\n:\n\"string\"\n}\n        }\n      }\n    },\n\"ForeignKeyConstraint\"\n: {\n\"title\"\n:\n\"Foreign Key Constraint\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"column_mapping\"\n,\n\"foreign_collection\"\n],\n\"properties\"\n: {\n\"column_mapping\"\n: {\n\"description\"\n:\n\"The columns on which you want want to define the foreign key.\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"type\"\n:\n\"string\"\n}\n        },\n\"foreign_collection\"\n: {\n\"description\"\n:\n\"The name of a collection\"\n,\n\"type\"\n:\n\"string\"\n}\n      }\n    },\n\"FunctionInfo\"\n: {\n\"title\"\n:\n\"Function Info\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"name\"\n,\n\"result_type\"\n],\n\"properties\"\n: {\n\"name\"\n: {\n\"description\"\n:\n\"The name of the function\"\n,\n\"type\"\n:\n\"string\"\n},\n\"description\"\n: {\n\"description\"\n:\n\"Description of the function\"\n,\n\"type\"\n: [\n\"string\"\n,\n\"null\"\n]\n        },\n\"arguments\"\n: {\n\"description\"\n:\n\"Any arguments that this collection requires\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/ArgumentInfo\"\n}\n        },\n\"result_type\"\n: {\n\"description\"\n:\n\"The name of the function's result type\"\n,\n\"allOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Type\"\n}\n          ]\n        }\n      }\n    },\n\"ProcedureInfo\"\n: {\n\"title\"\n:\n\"Procedure Info\"\n,\n\"type\"\n:\n\"object\"\n,\n\"required\"\n: [\n\"arguments\"\n,\n\"name\"\n,\n\"result_type\"\n],\n\"properties\"\n: {\n\"name\"\n: {\n\"description\"\n:\n\"The name of the procedure\"\n,\n\"type\"\n:\n\"string\"\n},\n\"description\"\n: {\n\"description\"\n:\n\"Column description\"\n,\n\"type\"\n: [\n\"string\"\n,\n\"null\"\n]\n        },\n\"arguments\"\n: {\n\"description\"\n:\n\"Any arguments that this collection requires\"\n,\n\"type\"\n:\n\"object\"\n,\n\"additionalProperties\"\n: {\n\"$ref\"\n:\n\"#/definitions/ArgumentInfo\"\n}\n        },\n\"result_type\"\n: {\n\"description\"\n:\n\"The name of the result type\"\n,\n\"allOf\"\n: [\n            {\n\"$ref\"\n:\n\"#/definitions/Type\"\n}\n          ]\n        }\n      }\n    }\n  }\n}\n```"
}